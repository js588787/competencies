# Знает и понимает, что такое макро и микро - таски

Event Loop является стеком, где хранятся все задачи, которые не вошли в синхронный поток выполнения.
После завершения синхронного потока - задачи начинают выполняться из Event Loop'а. Однако у Event Loop'а тоже есть свои правила:
- Сначала Event Loop проверяет выполнились ли все синхронные задачи
- Потом выполняются все задачи из микротасков
- После выполнения всех микротасков - очередь очищается
- Затем мы берем одну макрозадачу из списка и выполняем ее
- После выполнения мы смотрим нужно ли нам сделать перерисовку страницы
- Если перерисовать страницу нужно - делаем это
- Все снова начинается с первого пункта...

Макрозадачами являются все асинхронные операции:
- setTimeout
- setInterval
- requestAnimationFrame
- Ивенты пользователя
- AJAX-запросы
- Web Workers

В микрозадачи попадают:
- Promise.then()
- MutationObserver callbacks
- IntersectionObserver callbacks
- queueMicrotask(): Функция queueMicrotask() позволяет явно добавить микротаску в очередь микротасок. Это полезно, например, когда нужно гарантировать, что определенный код будет выполнен после всех текущих микротасок, независимо от того, сколько времени займет выполнение этих микротасок.

В задачи отрисовки попадают задачи связанные с отрисовкой и обновлением контента страницы.

# Знает и применяет методы call, apply, bind

Метод call
-
Метод call позволяет вызвать функцию с заданным значением this и аргументами, передаваемыми отдельно. Это означает, что вы можете явно указать, какое значение должно быть использовано вместо this внутри функции.

```javascript
function greet(greeting, punctuation) {
  console.log(`${greeting}, ${this.name}!${punctuation}`);
}

const person = { name: "John" };

// Использование call для изменения контекста this
greet.call(person, "Hello", ".");
// Вывод: Hello, John!. В этом случае this ссылается на объект person
```

Метод apply
-
Похож на call, но принимает два аргумента: первый - это значение this, а второй - массив аргументов, которые будут переданы функции. Это удобно, когда у вас есть много аргументов для передачи.

```javascript
function sum(a, b, c) {
  return a + b + c;
}

console.log(sum.apply(null, [1, 2, 3])); // Вывод: 6
```

Метод bind
-
Создает новую функцию, которая, при вызове, будет использовать указанное значение this. Отличие от call и apply заключается в том, что bind не выполняет функцию сразу, а возвращает ее для последующего вызова. Это полезно, когда вам нужно сохранить определенный контекст this для будущих вызовов функции.

```javascript
function greet(greeting, punctuation) {
  console.log(`${greeting}, ${this.name}!${punctuation}`);
}

const person = { name: "Jane" };
const boundGreet = greet.bind(person);

boundGreet("Hi"); // Вывод: Hi, Jane!
```

Основные моменты
-
- Все три метода (call, apply, bind) используются для изменения значения this внутри функции.
- call и apply выполняют функцию сразу же с заданным this и аргументами, в то время как bind возвращает новую функцию, которую можно вызвать позже.
- Выбор между этими методами зависит от конкретной ситуации и предпочтений разработчика. Важно понимать их различия и применять каждый из них там, где он наиболее подходит.

# Знает, как можно «запостить» файл на сервер
# Способы работы со стилями (scoped, css modules, БЭМ, глобальные стили) - плюсы и минусы каждого способа
# Знает и понимает, что такое макро и микро - таски.
# Понимает, как устроены и как манипулировать объектами в JS. Что такое объект-прототип
# Знает, как устроены область видимости в JS
# Знает, что такое замыкание
# Знает о них и применяет методы call, apply, bind
# Знает, как реализовать прототипное наследование в JS
# Умеет использовать основные инструменты разработчика в браузерах (инспектор html, отладка js, консоль, сеть)
# Умеет использовать инструменты для работы с js-кодом (статические анализаторы (jslint), минификаторы)
# Знает, что такое reflow/relayout, как оптимизировать работу с DOM
# Знает основные css3-селекторы и свойства
# Знает что таккое shadow DOM
# Знает о возможностях CSS (flex-box и т.д.)

# Понимает зачем нужна микроразметка, знает, что такое адаптивная верстка сайта

Микроразметка — это способ организации информации на веб-страницах, который позволяет поисковым системам лучше понимать и интерпретировать содержание страницы. Она используется для улучшения видимости сайта в поисковой выдаче и повышения качества представления информации о сайте в результатах поиска. Существует множество типов микроразметки, которые могут быть разделены на несколько основных категорий:
- Товары и услуги: Микроразметка для описания товаров и услуг, включая цены, наличие на складе, отзывы и рейтинги.
- Локации: Информация о географическом расположении, такие как адреса магазинов, часы работы, контактная информация.
- Персоны: Данные о людях, включая биографические сведения, профессии, достижения.
- События: Информация о мероприятиях, включая даты, места проведения, участников.
- Образование: Данные о курсах, программах обучения, учебных заведениях.
- Рецензии и отзывы: Микроразметка для отзывов о продуктах, услугах, местах и т.д., включая оценки и комментарии.
- Блоги и статьи: Информация о блог-постах и статьях, включая автора, дату публикации, категории и т.д.
- Медиа и контент: Микроразметка для изображений, видео, музыки, включая авторство, лицензионную информацию и т.д.

Форматы микроразметки
-
Самыми распространенными форматами микроразметки являются JSON-LD, Microdata и RDFa. Каждый из этих форматов имеет свои особенности и применяется в зависимости от конкретных потребностей и предпочтений разработчика.

- JSON-LD (JavaScript Object Notation for Linked Data): Представляет данные в формате JSON, легко читаемом как человеком, так и машинами. JSON-LD часто используется для добавления микроразметки непосредственно в HTML-документ.
- Microdata: Поддерживается всеми основными поисковыми системами и позволяет добавлять микроразметку прямо в HTML-атрибуты элементов.
- RDFa (Resource Description Framework in Attributes): Расширяет возможности HTML, добавляя микроразметку через специальные атрибуты.

Выбор формата микроразметки зависит от конкретных требований проекта и предпочтений разработчика. Важно следовать рекомендациям по микроразметке, предоставляемым поисковыми системами, чтобы обеспечить правильное отображение и индексацию информации о сайте.

Основные аспекты адаптивной верстки:
-
- Медиавыражения CSS: Это основной инструмент для реализации адаптивной верстки. Медиавыражения позволяют применять различные стили в зависимости от характеристик устройства, таких как ширина экрана. Например, можно определить разные стили для мобильных устройств, планшетов и настольных компьютеров.
- Резиновые макеты: Резиновая верстка использует относительные единицы измерения (такие как проценты), чтобы элементы на странице могли масштабироваться и подстраиваться под размер экрана. Это обеспечивает гибкость и позволяет контенту адаптироваться к различным размерам экранов.
- Гибкие изображения: Использование изображений, которые автоматически масштабируются и адаптируются к размеру экрана, также является важной частью адаптивной верстки. Это может быть достигнуто с помощью атрибута max-width в CSS, установленного в 100%.
- Прогрессивное улучшение: Эта стратегия предполагает, что базовая версия сайта будет работать даже если некоторые функции или стили не могут быть загружены или применены. Это обеспечивает лучшую совместимость и доступность для всех пользователей.

# Знает что такое promise и умеет применять его на практике

Промис - это специальный объект, который представляет собой результат асинхронной операции, который может быть успешным или неудачным.

Функция, переданная в конструкцию new Promise, называется исполнитель (executor). Когда Promise создаётся, она запускается автоматически. Она должна содержать «создающий» код, который когда-нибудь создаст результат.
Её аргументы resolve и reject – это колбэки, которые предоставляет сам JavaScript.

У объекта promise, возвращаемого конструктором new Promise, есть внутренние свойства:
- state («состояние») — вначале "pending" («ожидание»), потом меняется на "fulfilled" («выполнено успешно») при вызове resolve или на "rejected" («выполнено с ошибкой») при вызове reject.
- result («результат») — вначале undefined, далее изменяется на value при вызове resolve(value) или на error при вызове reject(error).

Создание промиса:

```javascript
const promise = new Promise((resolve, reject) => {
  // Асинхронная операция
  if (success) {
    resolve(result); // Переход в состояние fulfilled
  } else {
    reject(error); // Переход в состояние rejected  
  }
});
```

Обработка результата промиса:

```javascript
promise.then(
  result => { // Выполняется при успешном завершении
    console.log(result);
  },
  error => { // Выполняется при ошибке
    console.error(error);
  }
);
```

Цепочки промисов:

```javascript
doSomething()
  .then(result => doSomethingElse(result))
  .then(finalResult => console.log(finalResult))
  .catch(error => console.error(error));
```

Параллельное выполнение нескольких промисов:

```javascript
Promise.all([promise1, promise2, promise3])
  .then(results => console.log(results))
  .catch(error => console.error(error));
```

# Организация модулей (глобальный объект, CommonJS, UMD, ES modules)

Организация модулей в JavaScript — это ключевой аспект разработки масштабируемых и поддерживаемых приложений. Существует несколько подходов к организации модулей, каждый из которых имеет свои особенности и применяется в зависимости от контекста использования.

Глобальный объект
-

В начале развития JavaScript код часто организовывался через глобальные переменные и функции. Это простой подход, но он быстро становится неприемлемым по мере роста приложения из-за конфликтов имен и сложности управления зависимостями.

```javascript
// Глобальный объект
var myModule = {
  publicMethod: function() {
    // Код метода
  },
  privateMethod: function() {
    // Код метода
  }
};

// Использование
myModule.publicMethod();
```

CommonJS
-

CommonJS — это модульная система, которая была разработана для серверной стороны и широко используется в Node.js. Модули экспортируются с помощью module.exports или exports, а импортируются с помощью require.

```javascript
// myModule.js
const privateMethod = () => {
  // Код метода
};

const publicMethod = () => {
  // Код метода
};

module.exports = publicMethod;

// app.js
const myModule = require('./myModule');
myModule(); // Использование экспортированной функции
```

UMD (Universal Module Definition)
-

UMD позволяет создавать модули, совместимые с различными системами модулей, включая CommonJS и AMD, а также с использованием через тег <script> в браузерах. Это достигается путем определения универсального шаблона, который проверяет доступные среды и экспортирует модуль соответствующим образом.

```javascript
(function (root, factory) {
  if (typeof define === 'function' && define.amd) {
    // AMD
    define([], factory);
  } else if (typeof module === 'object' && module.exports) {
    // CommonJS
    module.exports = factory();
  } else {
    // Глобальная переменная для браузеров
    root.myModule = factory();
  }
}(this, function () {
  // Модуль
  return {};
}));
```

ES Modules
-
ES Modules (ECMAScript Modules) — это стандартная система модулей в JavaScript, введенная в ES6 (ES2015). Она использует ключевые слова import и export для импорта и экспорта функций, объектов или значений между модулями.

```javascript
// myModule.js
export const myFunction = () => {
  // Код функции
};

// app.js
import { myFunction } from './myModule';
myFunction(); // Использование импортированной функции
```

# Конфигурирование сборщиков vite / webpack / esbuild / bun

Конфигурирование сборщиков позволяет адаптировать процесс сборки проекта под конкретные требования и условия.

Vite
-
Vite предлагает простую и интуитивно понятную конфигурацию через файл vite.config.js. Основные возможности включают настройку сервера разработки, оптимизацию для продакшена, настройку плагинов и многое другое.

Пример базовой конфигурации Vite:

```javascript
// vite.config.js
import { defineConfig } from 'vite';

export default defineConfig({
  build: {
    outDir: 'dist', // Папка вывода для продакшена
    assetsDir: '', // Подкаталог для хранения ассетов
    sourcemap: false, // Генерация source map
    minify: 'esbuild', // Минификация с помощью esbuild
    target: 'es2017', // Целевая версия ECMAScript
  },
  server: {
    host: 'localhost', // Хост сервера разработки
    port: 3000, // Порт сервера разработки
    open: true, // Автоматическое открытие браузера
  },
});
```

Webpack
-
Webpack требует более детальной конфигурации через файл webpack.config.js. Он предлагает гораздо больше возможностей для настройки, включая обработку CSS, изображений, а также интеграцию с другими инструментами и плагинами.

Пример базовой конфигурации Webpack:

```javascript
// webpack.config.js
const path = require('path');

module.exports = {
  entry: './src/index.js', // Точка входа
  output: {
    filename: 'main.js', // Имя выходного файла
    path: path.resolve(__dirname, 'dist'), // Путь к папке вывода
  },
  module: {
    rules: [
      {
        test: /\.css$/, // Регулярное выражение для CSS файлов
        use: ['style-loader', 'css-loader'], // Загрузчики для CSS
      },
    ],
  },
  devServer: {
    contentBase: path.join(__dirname, 'dist'), // Корневая директория сервера разработки
    compress: true, // Включение gzip
    port: 9000, // Порт сервера разработки
  },
};
```

esbuild
-
esbuild предлагает простую и быструю сборку проектов с минимальной конфигурацией через файл esbuild.js.

Пример базовой конфигурации esbuild:

```javascript
// esbuild.js
require('esbuild').build({
  entryPoints: ['app.js'],
  bundle: true,
  outfile: 'out.js',
  platform: 'browser',
}).catch(() => process.exit(1))
```

Bun
-
Bun — относительно новый инструмент сборки, который стремится предложить быструю и эффективную сборку проектов. Он предлагает простую конфигурацию через файл bun.config.mjs.

Пример базовой конфигурации Bun:

```javascript
// bun.config.mjs
export default {
  input: 'src/main.ts',
  output: {
    file: 'dist/bundle.js',
    format: 'esm',
  },
  external: [],
  plugins: [],
};
```

# Hoisitng js

Поднятие задумывалось как общий способ мышления о том, как работает контекст выполнения. Однако, hoisting учит, что объявление переменной или функции физически перемещается в начало вашего кода, хотя в действительности этого не происходит. На самом же деле, объявления переменных и функций попадают в память в процессе фазы компиляции, но остаются в коде на том месте, где вы их объявили.
Одним из преимуществ помещения в память объявлений функций до выполнения кода является возможность использовать функцию до её объявления.
Переменные могут быть инициализированы и использованы до их объявления. Однако, они не могут быть использованы без инициализации.

# Работа с SVG (viewport, width, height, цвета, вставка в HTML и тд)

Работа с SVG (Scalable Vector Graphics) включает в себя управление такими концепциями, как viewBox, viewport, width, height, а также применение цветов и вставку SVG в HTML. Эти элементы позволяют контролировать масштабирование, панорамирование и отображение SVG-графики.

ViewBox
-
Этот атрибут определяет координатную систему и область содержимого SVG. Значение viewBox состоит из четырех разделенных пробелами параметров. Первые два параметра контролируют "панорамирование" (перемещение по горизонтали и вертикали), а последние два параметра контролируют "масштабирование". Увеличение первых двух параметров позволяет "панорамировать" вправо или вниз, соответственно. Увеличение последних двух параметров позволяет "увеличивать" масштаб графики.

Viewport
-
Это область просмотра, где отображается SVG-изображение на экране или внутри HTML-документа. Атрибуты width и height элемента SVG определяют размер области просмотра. Если соотношение сторон viewBox и viewport отличается, содержимое SVG масштабируется, чтобы поместиться в область просмотра, сохраняя при этом пропорции. Если соотношения сторон совпадают, содержимое SVG отображается без искажений.

Контроль размера и масштабирования
-
Width и Height: Эти атрибуты элемента SVG контролируют размер области просмотра. Они могут быть заданы в абсолютных единицах (например, пикселях) или в процентах от родительского элемента.

Цвета
-
Цвета в SVG задаются с помощью атрибутов fill (для заливки формы) и stroke (для цвета обводки). Эти атрибуты могут принимать значения в формате RGB, RGBA, HEX, HSL, HSLA и других.

Вставка SVG в HTML
-
SVG может быть встроен напрямую в HTML-код с помощью тега <svg> или вставлен как внешний ресурс с помощью тега <object>, <embed> или <iframe>. При встраивании SVG в HTML, атрибуты viewBox, width и height могут быть использованы для контроля масштабирования и отображения графики.

