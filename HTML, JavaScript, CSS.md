# Знает, как можно «запостить» файл на сервер

# Способы работы со стилями (scoped, css modules, БЭМ, глобальные стили) - плюсы и минусы каждого способа

# Знает и понимает, что такое макро и микро - таски

Event Loop является стеком, где хранятся все задачи, которые не вошли в синхронный поток выполнения.
После завершения синхронного потока - задачи начинают выполняться из Event Loop'а. Однако у Event Loop'а тоже есть свои правила:
- Сначала Event Loop проверяет выполнились ли все синхронные задачи
- Потом выполняются все задачи из микротасков
- После выполнения всех микротасков - очередь очищается
- Затем мы берем одну макрозадачу из списка и выполняем ее
- После выполнения мы смотрим нужно ли нам сделать перерисовку страницы
- Если перерисовать страницу нужно - делаем это
- Все снова начинается с первого пункта...

Макрозадачами являются все асинхронные операции:
- setTimeout
- setInterval
- requestAnimationFrame
- Ивенты пользователя
- AJAX-запросы
- Web Workers

В микрозадачи попадают:
- Promise.then()
- MutationObserver callbacks
- IntersectionObserver callbacks
- queueMicrotask(): Функция queueMicrotask() позволяет явно добавить микротаску в очередь микротасок. Это полезно, например, когда нужно гарантировать, что определенный код будет выполнен после всех текущих микротасок, независимо от того, сколько времени займет выполнение этих микротасок.

В задачи отрисовки попадают задачи связанные с отрисовкой и обновлением контента страницы.

# Знает и применяет методы call, apply, bind

Метод call
-
Метод call позволяет вызвать функцию с заданным значением this и аргументами, передаваемыми отдельно. Это означает, что вы можете явно указать, какое значение должно быть использовано вместо this внутри функции.

```javascript
function greet(greeting, punctuation) {
  console.log(`${greeting}, ${this.name}!${punctuation}`);
}

const person = { name: "John" };

// Использование call для изменения контекста this
greet.call(person, "Hello", ".");
// Вывод: Hello, John!. В этом случае this ссылается на объект person
```

Метод apply
-
Похож на call, но принимает два аргумента: первый - это значение this, а второй - массив аргументов, которые будут переданы функции. Это удобно, когда у вас есть много аргументов для передачи.

```javascript
function sum(a, b, c) {
  return a + b + c;
}

console.log(sum.apply(null, [1, 2, 3])); // Вывод: 6
```

Метод bind
-
Создает новую функцию, которая, при вызове, будет использовать указанное значение this. Отличие от call и apply заключается в том, что bind не выполняет функцию сразу, а возвращает ее для последующего вызова. Это полезно, когда вам нужно сохранить определенный контекст this для будущих вызовов функции.

```javascript
function greet(greeting, punctuation) {
  console.log(`${greeting}, ${this.name}!${punctuation}`);
}

const person = { name: "Jane" };
const boundGreet = greet.bind(person);

boundGreet("Hi"); // Вывод: Hi, Jane!
```

Основные моменты
-
- Все три метода (call, apply, bind) используются для изменения значения this внутри функции.
- call и apply выполняют функцию сразу же с заданным this и аргументами, в то время как bind возвращает новую функцию, которую можно вызвать позже.
- Выбор между этими методами зависит от конкретной ситуации и предпочтений разработчика. Важно понимать их различия и применять каждый из них там, где он наиболее подходит.

# Понимает, как устроены и как манипулировать объектами в JS. Что такое объект-прототип



# Знает, как устроены область видимости в JS



# Знает, что такое замыкание



# Знает о них и применяет методы call, apply, bind



# Знает, как реализовать прототипное наследование в JS



# Умеет использовать основные инструменты разработчика в браузерах (инспектор html, отладка js, консоль, сеть)



# Умеет использовать инструменты для работы с js-кодом (статические анализаторы (jslint), минификаторы)



# Знает, что такое reflow/relayout, как оптимизировать работу с DOM

Reflow (или relayout) — это процесс, при котором браузер пересчитывает позиции и геометрию элементов на веб-странице после внесения изменений, которые влияют на макет страницы или её части. Это может произойти из-за различных действий, таких как добавление, удаление или обновление DOM-узлов, изменение стилей элементов, анимация и даже действия пользователя, такие как изменение размера окна браузера или прокрутка страницы.
Reflow может быть дорогостоящим с точки зрения производительности, особенно на устройствах с ограниченной мощностью процессора. В некоторых случаях reflow может привести к перерасчету всего документа, что существенно замедляет работу интерфейса. Поэтому разработчики стремятся минимизировать количество reflow, оптимизируя изменения DOM и стилизацию элементов.

Repaints (Перерисовка)
-
Repaint возникает в случаях, если были изменены визуальные составляющие элемента, не затрагивающие его разметку. К примеру, opacity, background-color, visibility и outline. Repaint достаточно затратная штука с точки зрения производительности, т.к. браузер должен проверить видимость всех узлом DOM–под одним измененным элементом могут стать видимыми еще один или два.

Reflows (Перекомпановка)
-
Reflow же еще больше воздействуют на производительность. Во время этого процесса происходит перерасчет позиций и размеров всех элементов, что приводит к полной или частичной повторной отрисовке страницы. Изменения в одном элементе могут повлиять на все дочерние, родительские или смежные элементы.

Оба процесса блокируют браузер; и не пользователь, и не ваше веб-приложение не смогут ничего сделать во время reflow и repaint. В крайних случаях CSS эффекты могут затормозить выполнение JavaScript’а. Это одна из причин, почему вы сталкиваетесь с дергающейся прокруткой страницы и неотзывчивым интерфейсом.

Chrome Performance Tool и подобные инструменты позволяют анализировать, какие операции вызывают reflow и repaint, и определять места, где можно улучшить производительность. Это помогает разработчикам визуализировать влияние изменений на производительность и делать обоснованные решения по оптимизации.

Странно, но при попытке считать значения offsetWidth и offsetHeight элемента для их вычисления может быть запущен reflow.

Как минимизировать reflow?
-
- Группируйте изменения стилей и DOM-манипуляции вместе, чтобы минимизировать количество вызываемых reflow.
- Избегайте запроса стилевых свойств, которые могут привести к немедленному reflow, например, offsetHeight, непосредственно перед изменением стилей.
- Используйте CSS-свойства, которые меньше всего влияют на геометрию, например, изменяйте цвет фона вместо изменения границы.
- Рассмотрите возможность использования requestAnimationFrame для группировки анимаций и других изменений, которые могут вызвать reflow.

Полезно знать, в каких случаях запускается reflow:
-
- При добавлении, удалении или изменении видимого элемента DOM. Использование JavaScript для изменения DOM страницы вызывает reflow.
- При добавлении, удалении или изменении CSS стилей. Этот случай похож на первый, изменение стилей напрямую или изменение классов может повлиять на весь макет страницы. Изменив ширину элемента, вы можете повлиять на все элементы того же уровня в DOM и окружающие его элементы.
- CSS3 анимация и свойство transition. Каждый кадр анимации вызывает reflow.
- Использование offsetWidth и OffsetHeight. Странно, но при попытке считать значения offsetWidth и offsetHeight элемента для их вычисления может быть запущен reflow.
- Действия пользователя. И наконец пользователь может вызвать reflow, активировав состояние :hover, при вводе текста в поля, при изменении размера окна, изменении размера шрифта, переключении стилей или шрифтов.

Лучшии практики при создании макета:
- Не используйте инлайновые стили или таблицы в своих макетах!Инлайновые стили срабатывают только после окончательной загрузки HTML и вызывают дополнительный reflow.
- Таблицы снижают производительность, так как парсер не один раз проходится по таблице для вычисления размера ячейки.
- Table-layout: fixed может помочь при представлении табличных данных, так как ширина столбцов будет изменяться в зависимости от содержания строки заголовка.
- Flexbox на главной странице сайта также может привести к падению производительности, так как позиция и размеры ячейки могут измениться после окончательной загрузки HTML.
- Максимально сократите набор правил CSS. Чем меньше правил CSS, тем быстрее reflow. Также по возможности следует избегать сложных CSS селекторов.
- Особенно проблематично если вы используете фреймворк, например, Bootstrap – несколько сайтов используют одновременно больше половины всех стилей. Такие инструменты как UnusedCSS, uCSS, grunt-uncss, и gulp-uncss могут значительно сжать описание стилей и их вес.
- Минимизируйте провалы в DOM. С этим будет чуть сложнее – уменьшите размер вашего DOM и количества узлов в каждой ветке. Чем меньше и мельче ваш документ, тем быстрее будет reflow. Может быть, можно удалить ненужные элементы-обертки, если вы не поддерживаете старые браузеры.
- Как можно сильнее углубите изменения классов в DOM. Сделайте так, что бы при изменении стилей в классах, эти изменения затрагивали как можно более глубокие элементы в DOM (т.е. для тех элементов, у которых нет большого количества дочерних элементов, которые так же имеют большую вложенность). Данный шаг может сократить площадь reflow до пары узлов. По сути, если эффект на дочерние элементы минимален, необходимо применять изменения в классах только для родителей, таких как блоки-обертки.
- Удалите сложную анимацию из потока reflow. Добейтесь того, чтобы анимация применялась к элементам вне DOM. Этого можно достичь с помощью position: absolute или position: fixed. В таком случае изменение размеров и положения элемента не влияют на остальные элементы в документе.
- Изменяйте элементы в скрытом состоянии. Скрытые при помощи display: none элементы не повлекут за собой repaint или reflow во время изменения их стилей. На практике, перед тем, как сделать элемент видимым, старайтесь изменить необходимые для него стили.
- Ограничьте задействованные элементы. Избегайте ситуаций, когда в reflow может быть вовлечено огромное количество элементов. Можно рассмотреть систему вкладок (табов), по клику на таб видимым становится соответствующий блок. Окружающие элементы будут вовлечены в процесс в том случае, если все блоки будут иметь разную высоту. Производительность можно повысить, установив фиксированную высоту для контейнера, или удалив этот элемент.
- Признайте тот факт, что плавность анимации влияет на производительность. Передвигать элемент по пикселю в секунду может смотреться красиво и гладко, но для слабых устройств это затруднительно. Перемещение элемента на 4 пикселя в секунду снижает reflow в 4 раза, и почти незаметно для глаза.
- Анализируйте Repaint с помощью инструментария браузера. Все современные браузеры предоставляют разработчикам набор инструментов, позволяющий отслеживать то, как reflow влияет на производительность. В Blink/Webkit браузерах, таких как Chrome, Safari и Opera это можно сделать, открыв вкладку Сеть и записав активность.

# Знает основные css3-селекторы и свойства

Ну это мы знаем

# Знает что таккое shadow DOM

Один из главных преимуществ Shadow DOM — это изоляция стилей. Стили, определенные внутри Shadow DOM, не затрагивают глобальный DOM и наоборот. Это позволяет создавать компоненты без опасения конфликтов стилей.

```javascript
const shadowRoot = myElement.attachShadow({mode: 'open'});
```

Shadow DOM особенно полезен при создании веб-компонентов. Веб-компоненты — это способ создания пользовательских элементов, которые могут быть использованы в любом месте вашего приложения или даже в других приложениях.

# Знает о возможностях CSS (flex-box и т.д.)

Ну это мы знаем

# Понимает зачем нужна микроразметка, знает, что такое адаптивная верстка сайта

Микроразметка — это способ организации информации на веб-страницах, который позволяет поисковым системам лучше понимать и интерпретировать содержание страницы. Она используется для улучшения видимости сайта в поисковой выдаче и повышения качества представления информации о сайте в результатах поиска. Существует множество типов микроразметки, которые могут быть разделены на несколько основных категорий:
- Товары и услуги: Микроразметка для описания товаров и услуг, включая цены, наличие на складе, отзывы и рейтинги.
- Локации: Информация о географическом расположении, такие как адреса магазинов, часы работы, контактная информация.
- Персоны: Данные о людях, включая биографические сведения, профессии, достижения.
- События: Информация о мероприятиях, включая даты, места проведения, участников.
- Образование: Данные о курсах, программах обучения, учебных заведениях.
- Рецензии и отзывы: Микроразметка для отзывов о продуктах, услугах, местах и т.д., включая оценки и комментарии.
- Блоги и статьи: Информация о блог-постах и статьях, включая автора, дату публикации, категории и т.д.
- Медиа и контент: Микроразметка для изображений, видео, музыки, включая авторство, лицензионную информацию и т.д.

Форматы микроразметки
-
Самыми распространенными форматами микроразметки являются JSON-LD, Microdata и RDFa. Каждый из этих форматов имеет свои особенности и применяется в зависимости от конкретных потребностей и предпочтений разработчика.

- JSON-LD (JavaScript Object Notation for Linked Data): Представляет данные в формате JSON, легко читаемом как человеком, так и машинами. JSON-LD часто используется для добавления микроразметки непосредственно в HTML-документ.
- Microdata: Поддерживается всеми основными поисковыми системами и позволяет добавлять микроразметку прямо в HTML-атрибуты элементов.
- RDFa (Resource Description Framework in Attributes): Расширяет возможности HTML, добавляя микроразметку через специальные атрибуты.

Выбор формата микроразметки зависит от конкретных требований проекта и предпочтений разработчика. Важно следовать рекомендациям по микроразметке, предоставляемым поисковыми системами, чтобы обеспечить правильное отображение и индексацию информации о сайте.

Основные аспекты адаптивной верстки:
-
- Медиавыражения CSS: Это основной инструмент для реализации адаптивной верстки. Медиавыражения позволяют применять различные стили в зависимости от характеристик устройства, таких как ширина экрана. Например, можно определить разные стили для мобильных устройств, планшетов и настольных компьютеров.
- Резиновые макеты: Резиновая верстка использует относительные единицы измерения (такие как проценты), чтобы элементы на странице могли масштабироваться и подстраиваться под размер экрана. Это обеспечивает гибкость и позволяет контенту адаптироваться к различным размерам экранов.
- Гибкие изображения: Использование изображений, которые автоматически масштабируются и адаптируются к размеру экрана, также является важной частью адаптивной верстки. Это может быть достигнуто с помощью атрибута max-width в CSS, установленного в 100%.
- Прогрессивное улучшение: Эта стратегия предполагает, что базовая версия сайта будет работать даже если некоторые функции или стили не могут быть загружены или применены. Это обеспечивает лучшую совместимость и доступность для всех пользователей.

# Знает что такое promise и умеет применять его на практике

Промис - это специальный объект, который представляет собой результат асинхронной операции, который может быть успешным или неудачным.

Функция, переданная в конструкцию new Promise, называется исполнитель (executor). Когда Promise создаётся, она запускается автоматически. Она должна содержать «создающий» код, который когда-нибудь создаст результат.
Её аргументы resolve и reject – это колбэки, которые предоставляет сам JavaScript.

У объекта promise, возвращаемого конструктором new Promise, есть внутренние свойства:
- state («состояние») — вначале "pending" («ожидание»), потом меняется на "fulfilled" («выполнено успешно») при вызове resolve или на "rejected" («выполнено с ошибкой») при вызове reject.
- result («результат») — вначале undefined, далее изменяется на value при вызове resolve(value) или на error при вызове reject(error).

Создание промиса:

```javascript
const promise = new Promise((resolve, reject) => {
  // Асинхронная операция
  if (success) {
    resolve(result); // Переход в состояние fulfilled
  } else {
    reject(error); // Переход в состояние rejected  
  }
});
```

Обработка результата промиса:

```javascript
promise.then(
  result => { // Выполняется при успешном завершении
    console.log(result);
  },
  error => { // Выполняется при ошибке
    console.error(error);
  }
);
```

Цепочки промисов:

```javascript
doSomething()
  .then(result => doSomethingElse(result))
  .then(finalResult => console.log(finalResult))
  .catch(error => console.error(error));
```

Параллельное выполнение нескольких промисов:

```javascript
Promise.all([promise1, promise2, promise3])
  .then(results => console.log(results))
  .catch(error => console.error(error));
```

# Организация модулей (глобальный объект, CommonJS, UMD, ES modules)

Организация модулей в JavaScript — это ключевой аспект разработки масштабируемых и поддерживаемых приложений. Существует несколько подходов к организации модулей, каждый из которых имеет свои особенности и применяется в зависимости от контекста использования.

Глобальный объект
-

В начале развития JavaScript код часто организовывался через глобальные переменные и функции. Это простой подход, но он быстро становится неприемлемым по мере роста приложения из-за конфликтов имен и сложности управления зависимостями.

```javascript
// Глобальный объект
var myModule = {
  publicMethod: function() {
    // Код метода
  },
  privateMethod: function() {
    // Код метода
  }
};

// Использование
myModule.publicMethod();
```

CommonJS
-

CommonJS — это модульная система, которая была разработана для серверной стороны и широко используется в Node.js. Модули экспортируются с помощью module.exports или exports, а импортируются с помощью require.

```javascript
// myModule.js
const privateMethod = () => {
  // Код метода
};

const publicMethod = () => {
  // Код метода
};

module.exports = publicMethod;

// app.js
const myModule = require('./myModule');
myModule(); // Использование экспортированной функции
```

UMD (Universal Module Definition)
-

UMD позволяет создавать модули, совместимые с различными системами модулей, включая CommonJS и AMD, а также с использованием через тег <script> в браузерах. Это достигается путем определения универсального шаблона, который проверяет доступные среды и экспортирует модуль соответствующим образом.

```javascript
(function (root, factory) {
  if (typeof define === 'function' && define.amd) {
    // AMD
    define([], factory);
  } else if (typeof module === 'object' && module.exports) {
    // CommonJS
    module.exports = factory();
  } else {
    // Глобальная переменная для браузеров
    root.myModule = factory();
  }
}(this, function () {
  // Модуль
  return {};
}));
```

ES Modules
-
ES Modules (ECMAScript Modules) — это стандартная система модулей в JavaScript, введенная в ES6 (ES2015). Она использует ключевые слова import и export для импорта и экспорта функций, объектов или значений между модулями.

```javascript
// myModule.js
export const myFunction = () => {
  // Код функции
};

// app.js
import { myFunction } from './myModule';
myFunction(); // Использование импортированной функции
```

# Конфигурирование сборщиков vite / webpack / esbuild / bun

Конфигурирование сборщиков позволяет адаптировать процесс сборки проекта под конкретные требования и условия.

Vite
-
Vite предлагает простую и интуитивно понятную конфигурацию через файл vite.config.js. Основные возможности включают настройку сервера разработки, оптимизацию для продакшена, настройку плагинов и многое другое.

Пример базовой конфигурации Vite:

```javascript
// vite.config.js
import { defineConfig } from 'vite';

export default defineConfig({
  build: {
    outDir: 'dist', // Папка вывода для продакшена
    assetsDir: '', // Подкаталог для хранения ассетов
    sourcemap: false, // Генерация source map
    minify: 'esbuild', // Минификация с помощью esbuild
    target: 'es2017', // Целевая версия ECMAScript
  },
  server: {
    host: 'localhost', // Хост сервера разработки
    port: 3000, // Порт сервера разработки
    open: true, // Автоматическое открытие браузера
  },
});
```

Webpack
-
Webpack требует более детальной конфигурации через файл webpack.config.js. Он предлагает гораздо больше возможностей для настройки, включая обработку CSS, изображений, а также интеграцию с другими инструментами и плагинами.

Пример базовой конфигурации Webpack:

```javascript
// webpack.config.js
const path = require('path');

module.exports = {
  entry: './src/index.js', // Точка входа
  output: {
    filename: 'main.js', // Имя выходного файла
    path: path.resolve(__dirname, 'dist'), // Путь к папке вывода
  },
  module: {
    rules: [
      {
        test: /\.css$/, // Регулярное выражение для CSS файлов
        use: ['style-loader', 'css-loader'], // Загрузчики для CSS
      },
    ],
  },
  devServer: {
    contentBase: path.join(__dirname, 'dist'), // Корневая директория сервера разработки
    compress: true, // Включение gzip
    port: 9000, // Порт сервера разработки
  },
};
```

esbuild
-
esbuild предлагает простую и быструю сборку проектов с минимальной конфигурацией через файл esbuild.js.

Пример базовой конфигурации esbuild:

```javascript
// esbuild.js
require('esbuild').build({
  entryPoints: ['app.js'],
  bundle: true,
  outfile: 'out.js',
  platform: 'browser',
}).catch(() => process.exit(1))
```

Bun
-
Bun — относительно новый инструмент сборки, который стремится предложить быструю и эффективную сборку проектов. Он предлагает простую конфигурацию через файл bun.config.mjs.

Пример базовой конфигурации Bun:

```javascript
// bun.config.mjs
export default {
  input: 'src/main.ts',
  output: {
    file: 'dist/bundle.js',
    format: 'esm',
  },
  external: [],
  plugins: [],
};
```

# Hoisitng js

Поднятие задумывалось как общий способ мышления о том, как работает контекст выполнения. Однако, hoisting учит, что объявление переменной или функции физически перемещается в начало вашего кода, хотя в действительности этого не происходит. На самом же деле, объявления переменных и функций попадают в память в процессе фазы компиляции, но остаются в коде на том месте, где вы их объявили.
Одним из преимуществ помещения в память объявлений функций до выполнения кода является возможность использовать функцию до её объявления.
Переменные могут быть инициализированы и использованы до их объявления. Однако, они не могут быть использованы без инициализации.

# Работа с SVG (viewport, width, height, цвета, вставка в HTML и тд)

Работа с SVG (Scalable Vector Graphics) включает в себя управление такими концепциями, как viewBox, viewport, width, height, а также применение цветов и вставку SVG в HTML. Эти элементы позволяют контролировать масштабирование, панорамирование и отображение SVG-графики.

ViewBox
-
Этот атрибут определяет координатную систему и область содержимого SVG. Значение viewBox состоит из четырех разделенных пробелами параметров. Первые два параметра контролируют "панорамирование" (перемещение по горизонтали и вертикали), а последние два параметра контролируют "масштабирование". Увеличение первых двух параметров позволяет "панорамировать" вправо или вниз, соответственно. Увеличение последних двух параметров позволяет "увеличивать" масштаб графики.

Viewport
-
Это область просмотра, где отображается SVG-изображение на экране или внутри HTML-документа. Атрибуты width и height элемента SVG определяют размер области просмотра. Если соотношение сторон viewBox и viewport отличается, содержимое SVG масштабируется, чтобы поместиться в область просмотра, сохраняя при этом пропорции. Если соотношения сторон совпадают, содержимое SVG отображается без искажений.

Контроль размера и масштабирования
-
Width и Height: Эти атрибуты элемента SVG контролируют размер области просмотра. Они могут быть заданы в абсолютных единицах (например, пикселях) или в процентах от родительского элемента.

Цвета
-
Цвета в SVG задаются с помощью атрибутов fill (для заливки формы) и stroke (для цвета обводки). Эти атрибуты могут принимать значения в формате RGB, RGBA, HEX, HSL, HSLA и других.

Вставка SVG в HTML
-
SVG может быть встроен напрямую в HTML-код с помощью тега <svg> или вставлен как внешний ресурс с помощью тега <object>, <embed> или <iframe>. При встраивании SVG в HTML, атрибуты viewBox, width и height могут быть использованы для контроля масштабирования и отображения графики.

