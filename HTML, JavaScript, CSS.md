# Знает, что такое контекст выполнения? Что такое this?

Контекст выполнения (execution context) — это, если говорить упрощённо, концепция, описывающая окружение, в котором производится выполнение кода на JavaScript. Код всегда выполняется внутри некоего контекста.

Глобальный контекст выполнения
- Это базовый, используемый по умолчанию контекст выполнения. Если некий код находится не внутри какой-нибудь функции, значит этот код принадлежит глобальному контексту. Глобальный контекст характеризуется наличием глобального объекта, которым, в случае с браузером, является объект window, и тем, что ключевое слово this указывает на этот глобальный объект. В программе может быть лишь один глобальный контекст.

Контекст выполнения функции
- Каждый раз, когда вызывается функция, для неё создаётся новый контекст. Каждая функция имеет собственный контекст выполнения. В программе может одновременно присутствовать множество контекстов выполнения функций. При создании нового контекста выполнения функции он проходит через определённую последовательность шагов, о которой мы поговорим ниже.

Контекст выполнения функции eval
-
Код, выполняемый внутри функции eval, также имеет собственный контекст выполнения.

Стек выполнения (execution stack), который ещё называют стеком вызовов (call stack), это LIFO-стек, который используется для хранения контекстов выполнения, создаваемых в ходе работы кода.
Когда JS-движок начинает обрабатывать скрипт, движок создаёт глобальный контекст выполнения и помещает его в текущий стек. При обнаружении команды вызова функции движок создаёт новый контекст выполнения для этой функции и помещает его в верхнюю часть стека.
Движок выполняет функцию, контекст выполнения которой находится в верхней части стека. Когда работа функции завершается, её контекст извлекается из стека и управление передаётся тому контексту, который находится в предыдущем элементе стека.

Перед выполнением JavaScript-кода создаётся контекст выполнения. В процессе его создания выполняются три действия:

- Определяется значение this и осуществляется привязка this (this binding).
- Создаётся компонент LexicalEnvironment (лексическое окружение).
- Создаётся компонент VariableEnvironment (окружение переменных).

В глобальном контексте выполнения this содержит ссылку на глобальный объект (как уже было сказано, в браузере это объект window).
В контексте выполнения функции значение this зависит от того, как именно была вызвана функция. Если она вызвана в виде метода объекта, тогда значение this привязано к этому объекту. В других случаях this привязывается к глобальному объекту или устанавливается в undefined (в строгом режиме).

Лексическое окружение
-
В соответствии со спецификацией ES6, лексическое окружение (Lexical Environment) — это термин, который используется для определения связи между идентификаторами и отдельными переменными и функциями на основе структуры лексической вложенности ECMAScript-кода. Лексическое окружение состоит из записи окружения (Environment Record) и ссылки на внешнее лексическое окружение, которая может принимать значение null.
Проще говоря, лексическое окружение — это структура, которая хранит сведения о соответствии идентификаторов и переменных. Под «идентификатором» здесь понимается имя переменной или функции, а под «переменной» — ссылка на конкретный объект (в том числе — на функцию) или примитивное значение.

В лексическом окружении имеется два компонента:
- Запись окружения. Это место, где хранятся объявления переменных и функций.
- Ссылка на внешнее окружение. Наличие такой ссылки говорит о том, что у лексического окружения есть доступ к родительскому лексическому окружению (области видимости).

Существует два типа лексических окружений:

- Глобальное окружение (или глобальный контекст выполнения) — это лексическое окружение, у которого нет внешнего окружения. Ссылка глобального окружения на внешнее окружение представлена значением null. В глобальном окружении (в записи окружения) доступны встроенные сущности языка (такие, как Object, Array, и так далее), которые связаны с глобальным объектом, там же находятся и глобальные переменные, определённые пользователем. Значение this в этом окружении указывает на глобальный объект.
- Окружение функции, в котором, в записи окружения, хранятся переменные, объявленные пользователем. Ссылка на внешнее окружение может указывать как на глобальный объект, так и на внешнюю по отношении к рассматриваемой функции функцию.

Окружение переменных
-
Это тоже лексическое окружение, запись окружения которого хранит привязки, созданные посредством команд объявления переменных (VariableStatement) в текущем контексте выполнения.
Так как окружение переменных также является лексическим окружением, оно обладает всеми вышеописанными свойствами лексического окружения.

В ES6 существует одно различие между компонентами LexicalEnvironment и VariableEnvironment. Оно заключается в том, что первое используется для хранения объявлений функций и переменных, объявленных с помощью ключевых слов let и const, а второе — только для хранения привязок переменных, объявленных с использованием ключевого слова var.
Во время создания контекста в коде осуществляется поиск объявлений переменных и функций, при этом объявления функций целиком хранятся в окружении. Значения переменных, при использовании var, устанавливаются в undefined, а при использовании let или const остаются неинициализированными.
Именно поэтому можно получить доступ к переменным, объявленным с помощью var, до их объявления (хотя они и будут иметь значение undefined), но, при попытке доступа к переменным или константам, объявленным с помощью let и const, выполняемой до их объявления, возникает ошибка.
Только что мы только что описали, называется «поднятием переменных» (Hoisting). Объявления переменных «поднимаются» в верхнюю часть их лексической области видимости до выполнения операций присвоения им каких-либо значений.

Ключевое слово this в JavaScript относится к объекту, в контексте которого выполняется функция или метод. Значение this определяется способом вызова функции и может отличаться в зависимости от контекста использования.

Основные случаи использования this:
- В методе объекта: this ссылается на сам объект, к которому принадлежит метод. Это позволяет методу обращаться к свойствам и другим методам этого же объекта.
- Самостоятельно (вне функций): В глобальном контексте this обычно ссылается на глобальный объект (window в браузерах, global в Node.js).
- В функции: В обычной функции this также ссылается на глобальный объект, если функция вызывается не как метод объекта. Однако, если функция вызывается в строгом режиме ('use strict'), то this будет undefined.
- При обработке событий: В обработчиках событий this ссылается на элемент, который получил событие.
- С помощью методов call(), apply() и bind(): Эти методы позволяют явно задать значение this для вызова функции или создания новой функции с привязанным значением this.

Стрелочные функции не имеют своего собственного this. Они наследуют this из окружающего контекста, где они были объявлены. Это делает их полезными для коллбэков и сохранения контекста.
Понимание работы this в JavaScript критически важно для правильного использования объектно-ориентированного программирования и функций обратного вызова.

# Перехват и всплытие событий

Когда пользователь нажимает на элемент, генерируется событие, чтобы оповестить приложение об этом. Путешествие каждого события происходит в три стадии:
- Фаза погружения (capturing phase): Событие начинает свое путешествие от самого верхнего элемента документа (document) к целевому элементу.
- Целевая фаза (target phase): Событие достигает целевого элемента.
- Фаза всплытия (bubbling phase): После достижения целевого элемента, событие начинает движение обратно к вершине документа.

Событие создается снаружи документа и затем последовательно перемещается по DOM иерархии до target (целевого) элемента. Как только оно добралось до своей цели, событие тем же путем выбирается из DOM элемента.
Для срабатывании события на фазе погружения нужно указать true при подписке. Чтоб событие не всплывало к родителю - нужно вызвать ```event.stopPropagation();```

# Знает, как можно «запостить» файл на сервер

Через ```FormData```:
```javascript
const formData = new FormData();
formData.append('file', file);
```
# Способы работы со стилями (scoped, css modules, БЭМ, глобальные стили) - плюсы и минусы каждого способа

scoped
-
Это подход к организации CSS стилей в проектах, который обеспечивает изоляцию стилей для отдельных компонентов или частей приложения.

Плюсы
- Изоляция стилей: Scoped стили предотвращают конфликты между стилями разных компонентов, что особенно полезно в больших проектах.
- Улучшение читаемости кода: Разделение стилей на уровне компонентов делает код более организованным и легким для понимания.
- Локальная специфичность: Стили применяются только к соответствующему компоненту, уменьшая риск случайного влияния на другие части приложения.
- Упрощенное отладка: При возникновении проблем с стилями их проще локализовать и исправить.

Минусы
- Повышенная сложность: Использование scoped стилей может усложнить процесс написания и поддержки CSS.
- Ограничения наследования: Изоляция стилей может затруднить создание глобальных стилей или переопределение стилей дочерних элементов.
- Производительность: Генерация уникальных селекторов может увеличить размер CSS-файлов и потенциально повлиять на производительность.
- Необходимость дополнительных инструментов: Для работы со scoped стильями часто требуется использование препроцессоров или сборщиков (например, Webpack).
- Ограниченная совместимость: Некоторые старые браузеры могут не поддерживать все возможности, необходимые для корректной работы scoped стилей.
 
css modules
-
Это подход к организации CSS стилей, который позволяет организовать стили в модулях, таким образом, обеспечивая локальную область видимости, избегая конфликтов имен. 

Плюсы
- Изоляция стилей: каждый компонент имеет свой собственный набор стилей, не влияющих на другие части приложения.
- Уменьшение конфликтов имен: нет необходимости использовать префиксы или длинные идентификаторы классов.
- Гибкость в использовании: можно легко комбинировать стили из разных модулей.
- Чистота кода: каждый компонент содержит все необходимые стили, что упрощает понимание и поддержку

Минусы
- Сложность настройки: требует дополнительных шагов, таких как установка плагинов для сборщика и конфигурация.
- Ограниченная совместимость: не будет работать должным образом с некоторыми старыми браузерами или устаревшими версиями CSS.
- Дополнительная нагрузка на сборку: процесс компиляции CSS Modules может увеличить время сборки проекта, особенно в больших проектах.
- CSS Modules усложняют переиспользование стилей.
  
БЭМ
-
БЭМ представляет собой систему именования и организации селекторов, которая помогает создавать структурированные и переиспользуемые компоненты.

Блок

```html
<div class="button">
  <span class="button__text">Кнопка</span>
</div>
```

Элемент

```html
<div class="menu">
  <nav class="menu__list">
    <ul class="menu__items">
      <li class="menu__item"><a href="#" class="menu__link">Главная</a></li>
    </ul>
  </nav>
</div>
```

Модификатор

```html
<button class="button button_size_l button_color_blue">
  <span class="button__text">Крупная синяя кнопка</span>
</button>
```

Плюсы
- Структура и порядок: БЭМ обеспечивает четкую структуру и порядок именования компонентов.
- Переиспользование: Компоненты легко повторно использовать во многих проектах.
- Четкое разделение: Разделение блоков, элементов и модификаторов помогает в организации кода.
- Гибкость: Методология гибкая и подходит для различных типов проектов.
- Общепринятая система: Большинство российских разработчиков знакомы с БЭМ.

Минусы БЭМ
- Сложность для начинающих: Новая система может быть сложной для новичков.
- Требует соблюдения правил: Необходимо строго следовать принципам БЭМ.
- Может быть слишком жесткой: Некоторые считают ее слишком структурированной.
- Конфликты с другими системами: Может конфликтовать с другими методологиями.

глобальные стили
-

Глобальные стили - это стили CSS, которые определены вне HTML-документа, обычно в отдельном файле или внутри <style> тега в <head> секции HTML.

Плюсы
- Единообразие: Все страницы сайта используют одни и те же стили.
- Организация: Стили отделены от HTML-кода, что улучшает читаемость.
- Повторное использование: Можно легко повторно использовать стили на разных страницах.
- Упрощенная поддержка: Изменения в стилях нужно вносить только в одном месте.

Минусы
- Увеличение времени загрузки: Все стили загружаются вместе с HTML.
- Независимость от контента: Стили могут не соответствовать конкретному контенту.
- Сложности с переиспользованием: Трудно переиспользовать стили для разных контекстов.

# Понимает, как устроены и как манипулировать объектами в JS. Что такое объект-прототип

Объекты в JavaScript представляют собой набор свойств и методов, которые описывают характеристики и поведение объекта 5. Ключевые моменты:

Объекты состоят из пар ключ-значение, где ключ - это строка или символ, а значение может быть любым типом данных, включая функции. Свойства объекта можно создавать, читать, изменять и удалять динамически во время выполнения программы.

Создание объектов
Использование литерала объекта:
```javascript
let person = {
  name: "Иван",
  age: 30,
  sayHello: function() { console.log("Привет!"); }
};
```

Использование конструктора Object:
```javascript
let obj = new Object();
obj.name = "Пётр";
obj.age = 25;
```

Использование классов (ECMAScript 2015+):
```javascript
class Person {
  constructor(name, age) {
    this.name = name;
    this.age = age;
  }

  sayHello() {
    console.log(`Привет, меня зовут ${this.name}!`);
  }
}

let ivan = new Person("Иван", 30);
```

Доступ к свойствам
Через точку: ```person.name```
Через квадратные скобки: ```person["name"]```

Изменение свойств:
```person.age = 31;```
```person["age"] = 32;```

Добавление новых свойств:
```person.country = "Россия";```

Удаление свойств:
```delete person.age;```

Проверка существования свойства:
```javascript
if ("name" in person) {
  console.log("Свойство name существует");
}
```

Перебор свойств:
```javascript
for (let prop in person) {
  console.log(`${prop}: ${person[prop]}`);
}
```

Клонирование объектов:
```javascript
let copy = Object.assign({}, person);
// или
let deepCopy = JSON.parse(JSON.stringify(person));
```

# Знает, как устроены область видимости в JS

Область видимости (Scope) в JavaScript определяет доступность переменных, функций и объектов в различных частях кода во время выполнения программы. В JavaScript существуют два основных типа областей видимости: глобальная область видимости и локальная область видимости.

Глобальная область видимости
-
Переменные, объявленные вне всех функций или блоков кода, находятся в глобальной области видимости. Они доступны из любой части программы.

```javascript
var globalVar = "Я глобальная переменная";

function exampleFunction() {
    console.log(globalVar); // Доступ к глобальной переменной
}
```

Область видимости функции
-
Переменные, объявленные внутри функции, не доступны за её пределами.

```javascript
function exampleFunction() {
    var localVar = "Я локальная переменная";
    console.log(localVar); // Доступ к локальной переменной
}

exampleFunction(); // Выведет: Я локальная переменная
console.log(localVar); // Ошибка: localVar is not defined
```

Блочная область видимости
-
С введением ES6 в JavaScript появилась возможность создавать блочные области видимости с помощью ключевых слов let и const. Эти переменные доступны только внутри блока кода, в котором они были объявлены.

```javascript
if (true) {
    let blockVar = "Я переменная блочной области видимости";
    console.log(blockVar); // Доступ к blockVar внутри блока
}

console.log(blockVar); // Ошибка: blockVar is not defined
```

Вложенность областей видимости
-

Области видимости могут быть вложенными. Это означает, что внутренняя функция или блок имеет доступ к переменным внешней области видимости, но не наоборот.

```javascript
var outerVar = "Я внешняя переменная";

function outerFunction() {
    var innerVar = "Я внутренняя переменная";
    
    function innerFunction() {
        console.log(outerVar); // Доступ к внешней переменной
        console.log(innerVar); // Доступ к внутренней переменной
    }
    
    innerFunction();
}

outerFunction(); // Внутренняя функция имеет доступ к обоим переменным
console.log(outerVar); // Доступ к внешней переменной
console.log(innerVar); // Ошибка: innerVar is not defined
```

Понимание областей видимости важно для правильного управления переменными и предотвращения ошибок, связанных с их использованием в JavaScript.

# Знает, что такое замыкание

Замыкание (Closure) в JavaScript — это одна из самых мощных и интересных особенностей языка, которая позволяет функции запоминать и сохранять доступ к переменным из своих родительских областей видимости даже после того, как эти переменные больше не доступны в том контексте. Это ведёт к тому, что функция может "запоминать" значения переменных, которые были активны в момент её создания, и продолжать использовать их в будущем, даже если эти переменные уже не существуют в своём первоначальном контексте.

Как работает замыкание:
Когда функция объявлена внутри другой функции, она получает доступ к переменным внешней функции. Если эта внешняя функция возвращает внутреннюю функцию, то возвращённая функция сохраняет ссылку на переменные внешней функции. Это и называется замыканием.

Пример замыкания:

```javascript
function createCounter() {
    let count = 0; // Переменная внешнего контекста

    return function() { // Возвращаемая функция
        count += 1; // Используем переменную из внешнего контекста
        return count;
    };
}

const counter = createCounter();

console.log(counter()); // 1
console.log(counter()); // 2
console.log(counter()); // 3
```

В этом примере функция createCounter создаёт и возвращает другую функцию, которая использует переменную count из своей внешней области видимости. Таким образом, каждый раз, когда мы вызываем возвращённую функцию, она "запоминает" своё состояние благодаря замыканию.

Преимущества замыканий:
- Инкапсуляция: Замыкания позволяют скрыть детали реализации и сделать код более безопасным и удобочитаемым.
- Гибкость: Функции могут быть созданы и использованы в различных контекстах, сохраняя при этом свою функциональность.
- Универсальность: Замыкания используются во многих аспектах JavaScript, начиная от анонимных функций и кончая паттернами проектирования, такими как функциональные компоненты в React.

Недостатки замыканий:
- Высокий расход памяти: Замыкания могут привести к удержанию большого количества данных в памяти, поскольку они "запоминают" все переменные, к которым имели доступ.
- Сложности в отладке: Из-за того, что замыкания работают "за кулисами", отладка кода, использующего замыкания, может стать сложной.
- Замыкания являются фундаментальным понятием в JavaScript и играют ключевую роль в создании мощных и гибких решений. Понимание замыканий позволяет разработчикам писать более продвинутый и эффективный код.

# Знает и понимает, что такое макро и микро - таски

Event Loop является стеком, где хранятся все задачи, которые не вошли в синхронный поток выполнения.
После завершения синхронного потока - задачи начинают выполняться из Event Loop'а. Однако у Event Loop'а тоже есть свои правила:
- Сначала Event Loop проверяет выполнились ли все синхронные задачи
- Потом выполняются все задачи из микротасков
- После выполнения всех микротасков - очередь очищается
- Затем мы берем одну макрозадачу из списка и выполняем ее
- После выполнения мы смотрим нужно ли нам сделать перерисовку страницы
- Если перерисовать страницу нужно - делаем это
- Все снова начинается с первого пункта...

Макрозадачами являются все асинхронные операции:
- setTimeout
- setInterval
- requestAnimationFrame
- Ивенты пользователя
- AJAX-запросы
- Web Workers

В микрозадачи попадают:
- Promise.then()
- MutationObserver callbacks
- IntersectionObserver callbacks
- queueMicrotask(): Функция queueMicrotask() позволяет явно добавить микротаску в очередь микротасок. Это полезно, например, когда нужно гарантировать, что определенный код будет выполнен после всех текущих микротасок, независимо от того, сколько времени займет выполнение этих микротасок.

В задачи отрисовки попадают задачи связанные с отрисовкой и обновлением контента страницы.

# Знает и применяет методы call, apply, bind

Метод call
-
Метод call позволяет вызвать функцию с заданным значением this и аргументами, передаваемыми отдельно. Это означает, что вы можете явно указать, какое значение должно быть использовано вместо this внутри функции.

```javascript
function greet(greeting, punctuation) {
  console.log(`${greeting}, ${this.name}!${punctuation}`);
}

const person = { name: "John" };

// Использование call для изменения контекста this
greet.call(person, "Hello", ".");
// Вывод: Hello, John!. В этом случае this ссылается на объект person
```

Метод apply
-
Похож на call, но принимает два аргумента: первый - это значение this, а второй - массив аргументов, которые будут переданы функции. Это удобно, когда у вас есть много аргументов для передачи.

```javascript
function sum(a, b, c) {
  return a + b + c;
}

console.log(sum.apply(null, [1, 2, 3])); // Вывод: 6
```

Метод bind
-
Создает новую функцию, которая, при вызове, будет использовать указанное значение this. Отличие от call и apply заключается в том, что bind не выполняет функцию сразу, а возвращает ее для последующего вызова. Это полезно, когда вам нужно сохранить определенный контекст this для будущих вызовов функции.

```javascript
function greet(greeting, punctuation) {
  console.log(`${greeting}, ${this.name}!${punctuation}`);
}

const person = { name: "Jane" };
const boundGreet = greet.bind(person);

boundGreet("Hi"); // Вывод: Hi, Jane!
```

Основные моменты
-
- Все три метода (call, apply, bind) используются для изменения значения this внутри функции.
- call и apply выполняют функцию сразу же с заданным this и аргументами, в то время как bind возвращает новую функцию, которую можно вызвать позже.
- Выбор между этими методами зависит от конкретной ситуации и предпочтений разработчика. Важно понимать их различия и применять каждый из них там, где он наиболее подходит.

# Знает, как реализовать прототипное наследование в JS

Для реализации наследования в JavaScript можно использовать функцию ```Object.create()``` или установить свойство prototype для конструктора. Можно это сделать через свойство ```__proto__```, которое устарело, лучше использовать ```Object.getPrototypeOf/Object.setPrototypeOf```.

# Умеет использовать основные инструменты разработчика в браузерах (инспектор html, отладка js, консоль, сеть)

Мы это, вроде, знаем.

# Умеет использовать инструменты для работы с js-кодом (статические анализаторы (jslint), минификаторы)

Статический анализ кода — это методика проверки исходного кода программы на наличие багов, уязвимостей безопасности и несоответствий стилю кодирования без его фактического выполнения. Для JavaScript существует несколько популярных инструментов статического анализа, включая JSLint, ESLint, и Prettier.

Анализаторы можно интегрировать со средами разработки и инструментами сборки и ci/cd для автоматической проверки качества кода.

Минификация — это процесс удаления всех ненужных символов из исходного кода без изменения его функциональности. Это включает в себя удаление пробелов, переносов строк, комментариев и сокращение длинных идентификаторов переменных до коротких. Минификация используется для уменьшения размера файлов JavaScript, CSS и HTML, что приводит к увеличению скорости загрузки веб-страниц.
Минификаторы интегрируются с инструментами сборки. Vite автоматически обрабатывает минификацию JavaScript и CSS в режиме продакшена, используя встроенные плагины и оптимизации. По умолчанию, Vite использует terser для минификации JavaScript и cssnano для минификации CSS.

# Знает, что такое reflow/relayout, как оптимизировать работу с DOM

Reflow (или relayout) — это процесс, при котором браузер пересчитывает позиции и геометрию элементов на веб-странице после внесения изменений, которые влияют на макет страницы или её части. Это может произойти из-за различных действий, таких как добавление, удаление или обновление DOM-узлов, изменение стилей элементов, анимация и даже действия пользователя, такие как изменение размера окна браузера или прокрутка страницы.
Reflow может быть дорогостоящим с точки зрения производительности, особенно на устройствах с ограниченной мощностью процессора. В некоторых случаях reflow может привести к перерасчету всего документа, что существенно замедляет работу интерфейса. Поэтому разработчики стремятся минимизировать количество reflow, оптимизируя изменения DOM и стилизацию элементов.

Repaints (Перерисовка)
-
Repaint возникает в случаях, если были изменены визуальные составляющие элемента, не затрагивающие его разметку. К примеру, opacity, background-color, visibility и outline. Repaint достаточно затратная штука с точки зрения производительности, т.к. браузер должен проверить видимость всех узлом DOM–под одним измененным элементом могут стать видимыми еще один или два.

Reflows (Перекомпановка)
-
Reflow же еще больше воздействуют на производительность. Во время этого процесса происходит перерасчет позиций и размеров всех элементов, что приводит к полной или частичной повторной отрисовке страницы. Изменения в одном элементе могут повлиять на все дочерние, родительские или смежные элементы.

Оба процесса блокируют браузер; и не пользователь, и не ваше веб-приложение не смогут ничего сделать во время reflow и repaint. В крайних случаях CSS эффекты могут затормозить выполнение JavaScript’а. Это одна из причин, почему вы сталкиваетесь с дергающейся прокруткой страницы и неотзывчивым интерфейсом.

Chrome Performance Tool и подобные инструменты позволяют анализировать, какие операции вызывают reflow и repaint, и определять места, где можно улучшить производительность. Это помогает разработчикам визуализировать влияние изменений на производительность и делать обоснованные решения по оптимизации.

Странно, но при попытке считать значения offsetWidth и offsetHeight элемента для их вычисления может быть запущен reflow.

Как минимизировать reflow?
-
- Группируйте изменения стилей и DOM-манипуляции вместе, чтобы минимизировать количество вызываемых reflow.
- Избегайте запроса стилевых свойств, которые могут привести к немедленному reflow, например, offsetHeight, непосредственно перед изменением стилей.
- Используйте CSS-свойства, которые меньше всего влияют на геометрию, например, изменяйте цвет фона вместо изменения границы.
- Рассмотрите возможность использования requestAnimationFrame для группировки анимаций и других изменений, которые могут вызвать reflow.

Полезно знать, в каких случаях запускается reflow:
-
- При добавлении, удалении или изменении видимого элемента DOM. Использование JavaScript для изменения DOM страницы вызывает reflow.
- При добавлении, удалении или изменении CSS стилей. Этот случай похож на первый, изменение стилей напрямую или изменение классов может повлиять на весь макет страницы. Изменив ширину элемента, вы можете повлиять на все элементы того же уровня в DOM и окружающие его элементы.
- CSS3 анимация и свойство transition. Каждый кадр анимации вызывает reflow.
- Использование offsetWidth и OffsetHeight. Странно, но при попытке считать значения offsetWidth и offsetHeight элемента для их вычисления может быть запущен reflow.
- Действия пользователя. И наконец пользователь может вызвать reflow, активировав состояние :hover, при вводе текста в поля, при изменении размера окна, изменении размера шрифта, переключении стилей или шрифтов.

Лучшии практики при создании макета:
- Не используйте инлайновые стили или таблицы в своих макетах!Инлайновые стили срабатывают только после окончательной загрузки HTML и вызывают дополнительный reflow.
- Таблицы снижают производительность, так как парсер не один раз проходится по таблице для вычисления размера ячейки.
- Table-layout: fixed может помочь при представлении табличных данных, так как ширина столбцов будет изменяться в зависимости от содержания строки заголовка.
- Flexbox на главной странице сайта также может привести к падению производительности, так как позиция и размеры ячейки могут измениться после окончательной загрузки HTML.
- Максимально сократите набор правил CSS. Чем меньше правил CSS, тем быстрее reflow. Также по возможности следует избегать сложных CSS селекторов.
- Особенно проблематично если вы используете фреймворк, например, Bootstrap – несколько сайтов используют одновременно больше половины всех стилей. Такие инструменты как UnusedCSS, uCSS, grunt-uncss, и gulp-uncss могут значительно сжать описание стилей и их вес.
- Минимизируйте провалы в DOM. С этим будет чуть сложнее – уменьшите размер вашего DOM и количества узлов в каждой ветке. Чем меньше и мельче ваш документ, тем быстрее будет reflow. Может быть, можно удалить ненужные элементы-обертки, если вы не поддерживаете старые браузеры.
- Как можно сильнее углубите изменения классов в DOM. Сделайте так, что бы при изменении стилей в классах, эти изменения затрагивали как можно более глубокие элементы в DOM (т.е. для тех элементов, у которых нет большого количества дочерних элементов, которые так же имеют большую вложенность). Данный шаг может сократить площадь reflow до пары узлов. По сути, если эффект на дочерние элементы минимален, необходимо применять изменения в классах только для родителей, таких как блоки-обертки.
- Удалите сложную анимацию из потока reflow. Добейтесь того, чтобы анимация применялась к элементам вне DOM. Этого можно достичь с помощью position: absolute или position: fixed. В таком случае изменение размеров и положения элемента не влияют на остальные элементы в документе.
- Изменяйте элементы в скрытом состоянии. Скрытые при помощи display: none элементы не повлекут за собой repaint или reflow во время изменения их стилей. На практике, перед тем, как сделать элемент видимым, старайтесь изменить необходимые для него стили.
- Ограничьте задействованные элементы. Избегайте ситуаций, когда в reflow может быть вовлечено огромное количество элементов. Можно рассмотреть систему вкладок (табов), по клику на таб видимым становится соответствующий блок. Окружающие элементы будут вовлечены в процесс в том случае, если все блоки будут иметь разную высоту. Производительность можно повысить, установив фиксированную высоту для контейнера, или удалив этот элемент.
- Признайте тот факт, что плавность анимации влияет на производительность. Передвигать элемент по пикселю в секунду может смотреться красиво и гладко, но для слабых устройств это затруднительно. Перемещение элемента на 4 пикселя в секунду снижает reflow в 4 раза, и почти незаметно для глаза.
- Анализируйте Repaint с помощью инструментария браузера. Все современные браузеры предоставляют разработчикам набор инструментов, позволяющий отслеживать то, как reflow влияет на производительность. В Blink/Webkit браузерах, таких как Chrome, Safari и Opera это можно сделать, открыв вкладку Сеть и записав активность.

# Знает основные css3-селекторы и свойства

Ну это мы знаем

# Знает что таккое shadow DOM

Один из главных преимуществ Shadow DOM — это изоляция стилей. Стили, определенные внутри Shadow DOM, не затрагивают глобальный DOM и наоборот. Это позволяет создавать компоненты без опасения конфликтов стилей.

```javascript
const shadowRoot = myElement.attachShadow({mode: 'open'});
```

Shadow DOM особенно полезен при создании веб-компонентов. Веб-компоненты — это способ создания пользовательских элементов, которые могут быть использованы в любом месте вашего приложения или даже в других приложениях.

# Знает о возможностях CSS (flex-box и т.д.)

Это мы знаем

# Понимает зачем нужна микроразметка, знает, что такое адаптивная верстка сайта

Микроразметка — это способ организации информации на веб-страницах, который позволяет поисковым системам лучше понимать и интерпретировать содержание страницы. Она используется для улучшения видимости сайта в поисковой выдаче и повышения качества представления информации о сайте в результатах поиска. Существует множество типов микроразметки, которые могут быть разделены на несколько основных категорий:
- Товары и услуги: Микроразметка для описания товаров и услуг, включая цены, наличие на складе, отзывы и рейтинги.
- Локации: Информация о географическом расположении, такие как адреса магазинов, часы работы, контактная информация.
- Персоны: Данные о людях, включая биографические сведения, профессии, достижения.
- События: Информация о мероприятиях, включая даты, места проведения, участников.
- Образование: Данные о курсах, программах обучения, учебных заведениях.
- Рецензии и отзывы: Микроразметка для отзывов о продуктах, услугах, местах и т.д., включая оценки и комментарии.
- Блоги и статьи: Информация о блог-постах и статьях, включая автора, дату публикации, категории и т.д.
- Медиа и контент: Микроразметка для изображений, видео, музыки, включая авторство, лицензионную информацию и т.д.

Форматы микроразметки
-
Самыми распространенными форматами микроразметки являются JSON-LD, Microdata и RDFa. Каждый из этих форматов имеет свои особенности и применяется в зависимости от конкретных потребностей и предпочтений разработчика.

- JSON-LD (JavaScript Object Notation for Linked Data): Представляет данные в формате JSON, легко читаемом как человеком, так и машинами. JSON-LD часто используется для добавления микроразметки непосредственно в HTML-документ.
- Microdata: Поддерживается всеми основными поисковыми системами и позволяет добавлять микроразметку прямо в HTML-атрибуты элементов.
- RDFa (Resource Description Framework in Attributes): Расширяет возможности HTML, добавляя микроразметку через специальные атрибуты.

Выбор формата микроразметки зависит от конкретных требований проекта и предпочтений разработчика. Важно следовать рекомендациям по микроразметке, предоставляемым поисковыми системами, чтобы обеспечить правильное отображение и индексацию информации о сайте.

Основные аспекты адаптивной верстки:
-
- Медиавыражения CSS: Это основной инструмент для реализации адаптивной верстки. Медиавыражения позволяют применять различные стили в зависимости от характеристик устройства, таких как ширина экрана. Например, можно определить разные стили для мобильных устройств, планшетов и настольных компьютеров.
- Резиновые макеты: Резиновая верстка использует относительные единицы измерения (такие как проценты), чтобы элементы на странице могли масштабироваться и подстраиваться под размер экрана. Это обеспечивает гибкость и позволяет контенту адаптироваться к различным размерам экранов.
- Гибкие изображения: Использование изображений, которые автоматически масштабируются и адаптируются к размеру экрана, также является важной частью адаптивной верстки. Это может быть достигнуто с помощью атрибута max-width в CSS, установленного в 100%.
- Прогрессивное улучшение: Эта стратегия предполагает, что базовая версия сайта будет работать даже если некоторые функции или стили не могут быть загружены или применены. Это обеспечивает лучшую совместимость и доступность для всех пользователей.

# Знает что такое promise и умеет применять его на практике

Промис - это специальный объект, который представляет собой результат асинхронной операции, который может быть успешным или неудачным.

Функция, переданная в конструкцию new Promise, называется исполнитель (executor). Когда Promise создаётся, она запускается автоматически. Она должна содержать «создающий» код, который когда-нибудь создаст результат.
Её аргументы resolve и reject – это колбэки, которые предоставляет сам JavaScript.

У объекта promise, возвращаемого конструктором new Promise, есть внутренние свойства:
- state («состояние») — вначале "pending" («ожидание»), потом меняется на "fulfilled" («выполнено успешно») при вызове resolve или на "rejected" («выполнено с ошибкой») при вызове reject.
- result («результат») — вначале undefined, далее изменяется на value при вызове resolve(value) или на error при вызове reject(error).

Создание промиса:

```javascript
const promise = new Promise((resolve, reject) => {
  // Асинхронная операция
  if (success) {
    resolve(result); // Переход в состояние fulfilled
  } else {
    reject(error); // Переход в состояние rejected  
  }
});
```

Обработка результата промиса:

```javascript
promise.then(
  result => { // Выполняется при успешном завершении
    console.log(result);
  },
  error => { // Выполняется при ошибке
    console.error(error);
  }
);
```

Цепочки промисов:

```javascript
doSomething()
  .then(result => doSomethingElse(result))
  .then(finalResult => console.log(finalResult))
  .catch(error => console.error(error));
```

Параллельное выполнение нескольких промисов:

```javascript
Promise.all([promise1, promise2, promise3])
  .then(results => console.log(results))
  .catch(error => console.error(error));
```

# Организация модулей (глобальный объект, CommonJS, UMD, ES modules)

Организация модулей в JavaScript — это ключевой аспект разработки масштабируемых и поддерживаемых приложений. Существует несколько подходов к организации модулей, каждый из которых имеет свои особенности и применяется в зависимости от контекста использования.

Глобальный объект
-

В начале развития JavaScript код часто организовывался через глобальные переменные и функции. Это простой подход, но он быстро становится неприемлемым по мере роста приложения из-за конфликтов имен и сложности управления зависимостями.

```javascript
// Глобальный объект
var myModule = {
  publicMethod: function() {
    // Код метода
  },
  privateMethod: function() {
    // Код метода
  }
};

// Использование
myModule.publicMethod();
```

CommonJS
-

CommonJS — это модульная система, которая была разработана для серверной стороны и широко используется в Node.js. Модули экспортируются с помощью module.exports или exports, а импортируются с помощью require.

```javascript
// myModule.js
const privateMethod = () => {
  // Код метода
};

const publicMethod = () => {
  // Код метода
};

module.exports = publicMethod;

// app.js
const myModule = require('./myModule');
myModule(); // Использование экспортированной функции
```

UMD (Universal Module Definition)
-

UMD позволяет создавать модули, совместимые с различными системами модулей, включая CommonJS и AMD, а также с использованием через тег <script> в браузерах. Это достигается путем определения универсального шаблона, который проверяет доступные среды и экспортирует модуль соответствующим образом.

```javascript
(function (root, factory) {
  if (typeof define === 'function' && define.amd) {
    // AMD
    define([], factory);
  } else if (typeof module === 'object' && module.exports) {
    // CommonJS
    module.exports = factory();
  } else {
    // Глобальная переменная для браузеров
    root.myModule = factory();
  }
}(this, function () {
  // Модуль
  return {};
}));
```

ES Modules
-
ES Modules (ECMAScript Modules) — это стандартная система модулей в JavaScript, введенная в ES6 (ES2015). Она использует ключевые слова import и export для импорта и экспорта функций, объектов или значений между модулями.

```javascript
// myModule.js
export const myFunction = () => {
  // Код функции
};

// app.js
import { myFunction } from './myModule';
myFunction(); // Использование импортированной функции
```

# Конфигурирование сборщиков vite / webpack / esbuild / bun

Конфигурирование сборщиков позволяет адаптировать процесс сборки проекта под конкретные требования и условия.

Vite
-
Vite предлагает простую и интуитивно понятную конфигурацию через файл vite.config.js. Основные возможности включают настройку сервера разработки, оптимизацию для продакшена, настройку плагинов и многое другое.

Пример базовой конфигурации Vite:

```javascript
// vite.config.js
import { defineConfig } from 'vite';

export default defineConfig({
  build: {
    outDir: 'dist', // Папка вывода для продакшена
    assetsDir: '', // Подкаталог для хранения ассетов
    sourcemap: false, // Генерация source map
    minify: 'esbuild', // Минификация с помощью esbuild
    target: 'es2017', // Целевая версия ECMAScript
  },
  server: {
    host: 'localhost', // Хост сервера разработки
    port: 3000, // Порт сервера разработки
    open: true, // Автоматическое открытие браузера
  },
});
```

Webpack
-
Webpack требует более детальной конфигурации через файл webpack.config.js. Он предлагает гораздо больше возможностей для настройки, включая обработку CSS, изображений, а также интеграцию с другими инструментами и плагинами.

Пример базовой конфигурации Webpack:

```javascript
// webpack.config.js
const path = require('path');

module.exports = {
  entry: './src/index.js', // Точка входа
  output: {
    filename: 'main.js', // Имя выходного файла
    path: path.resolve(__dirname, 'dist'), // Путь к папке вывода
  },
  module: {
    rules: [
      {
        test: /\.css$/, // Регулярное выражение для CSS файлов
        use: ['style-loader', 'css-loader'], // Загрузчики для CSS
      },
    ],
  },
  devServer: {
    contentBase: path.join(__dirname, 'dist'), // Корневая директория сервера разработки
    compress: true, // Включение gzip
    port: 9000, // Порт сервера разработки
  },
};
```

esbuild
-
esbuild предлагает простую и быструю сборку проектов с минимальной конфигурацией через файл esbuild.js.

Пример базовой конфигурации esbuild:

```javascript
// esbuild.js
require('esbuild').build({
  entryPoints: ['app.js'],
  bundle: true,
  outfile: 'out.js',
  platform: 'browser',
}).catch(() => process.exit(1))
```

Bun
-
Bun — относительно новый инструмент сборки, который стремится предложить быструю и эффективную сборку проектов. Он предлагает простую конфигурацию через файл bun.config.mjs.

Пример базовой конфигурации Bun:

```javascript
// bun.config.mjs
export default {
  input: 'src/main.ts',
  output: {
    file: 'dist/bundle.js',
    format: 'esm',
  },
  external: [],
  plugins: [],
};
```

# Hoisitng js

Поднятие задумывалось как общий способ мышления о том, как работает контекст выполнения. Однако, hoisting учит, что объявление переменной или функции физически перемещается в начало вашего кода, хотя в действительности этого не происходит. На самом же деле, объявления переменных и функций попадают в память в процессе фазы компиляции, но остаются в коде на том месте, где вы их объявили.
Одним из преимуществ помещения в память объявлений функций до выполнения кода является возможность использовать функцию до её объявления.
Переменные могут быть инициализированы и использованы до их объявления. Однако, они не могут быть использованы без инициализации.

# Работа с SVG (viewport, width, height, цвета, вставка в HTML и тд)

Работа с SVG (Scalable Vector Graphics) включает в себя управление такими концепциями, как viewBox, viewport, width, height, а также применение цветов и вставку SVG в HTML. Эти элементы позволяют контролировать масштабирование, панорамирование и отображение SVG-графики.

ViewBox
-
Этот атрибут определяет координатную систему и область содержимого SVG. Значение viewBox состоит из четырех разделенных пробелами параметров. Первые два параметра контролируют "панорамирование" (перемещение по горизонтали и вертикали), а последние два параметра контролируют "масштабирование". Увеличение первых двух параметров позволяет "панорамировать" вправо или вниз, соответственно. Увеличение последних двух параметров позволяет "увеличивать" масштаб графики.

Viewport
-
Это область просмотра, где отображается SVG-изображение на экране или внутри HTML-документа. Атрибуты width и height элемента SVG определяют размер области просмотра. Если соотношение сторон viewBox и viewport отличается, содержимое SVG масштабируется, чтобы поместиться в область просмотра, сохраняя при этом пропорции. Если соотношения сторон совпадают, содержимое SVG отображается без искажений.

Контроль размера и масштабирования
-
Width и Height: Эти атрибуты элемента SVG контролируют размер области просмотра. Они могут быть заданы в абсолютных единицах (например, пикселях) или в процентах от родительского элемента.

Цвета
-
Цвета в SVG задаются с помощью атрибутов fill (для заливки формы) и stroke (для цвета обводки). Эти атрибуты могут принимать значения в формате RGB, RGBA, HEX, HSL, HSLA и других.

Вставка SVG в HTML
-
SVG может быть встроен напрямую в HTML-код с помощью тега <svg> или вставлен как внешний ресурс с помощью тега <object>, <embed> или <iframe>. При встраивании SVG в HTML, атрибуты viewBox, width и height могут быть использованы для контроля масштабирования и отображения графики.

# Знает, каким образом в приложении можно организовать обмен данных между двумя окнами (window), если одно дочернее и второе родительское?

Обмен данными между окнами в веб-приложениях может быть организован несколькими способами, включая использование локального хранилища (localStorage), глобальных переменных, сообщений через postMessage API и даже через общий источник данных, такой как серверная база данных. В контексте вопроса, где одно окно является дочерним (обычно всплывающим окном или модальным окном), а другое — родительским, наиболее подходящими будут методы, основанные на взаимодействии через postMessage API и использование общих источников данных.

Использование postMessage API
-
postMessage позволяет безопасно отправлять сообщения между окнами, независимо от того, являются ли они родительскими или дочерними. Это идеальный способ для обмена данными между окнами, поскольку он не зависит от структуры дом-дерева и обеспечивает безопасность благодаря механизмам защиты от межсайтового скриптинга (CORS).

Отправка сообщения из дочернего окна:
```javascript
// В дочернем окне
let dataToSend = { message: "Hello from child window!" };

if (window.parent !== window.self) {
  window.parent.postMessage(dataToSend, "*");
}
```

Получение сообщения в родительском окне:
```javascript
// В родительском окне
window.addEventListener("message", (event) => {
  let receivedData = event.data;
  console.log(receivedData); // Обработка полученного сообщения
}, false);

// Также можно установить список доверенных источников для безопасности
window.addEventListener("message", (event) => {
  if (event.origin !== "http://trusted.com") {
    return;
  }

  let receivedData = event.data;
  console.log(receivedData); // Обработка полученного сообщения
}, false);
```

# Знает, как работать с Canvas

Canvas — это элемент HTML5, который позволяет рисовать графику с помощью JavaScript. Он представляет собой область на веб-странице, где можно рисовать линии, формы, текст и изображения. Canvas поддерживает различные типы графики, включая 2D и WebGL для 3D графики.

Создание элемента Canvas
Чтобы использовать Canvas, сначала необходимо добавить элемент <canvas> в HTML-структуру вашей страницы:

```html
<canvas id="myCanvas" width="800" height="600" style="border:1px solid #000000;"></canvas>
```

```javascript
const canvas = document.getElementById('myCanvas');
const ctx = canvas.getContext('2d');

// Рисование прямой линии
ctx.beginPath();
ctx.moveTo(0, 0); // Начало линии
ctx.lineTo(200, 100); // Конец линии
ctx.stroke();

// Рисование прямой линии
ctx.beginPath();
ctx.moveTo(0, 0); // Начало линии
ctx.lineTo(200, 100); // Конец линии
ctx.stroke();

// Рисование круга
ctx.beginPath();
ctx.arc(100, 100, 50, 0, Math.PI * 2, true); // Центр (x, y), радиус, начальный угол, конечный угол, направление (true - по часовой стрелке)
ctx.fill();

// Рисование текста
ctx.font = '30px Arial'; // Шрифт и размер
ctx.fillText('Hello World!', 50, 150); // Текст, x, y
```

Работа с 3D контекстом (WebGL)
Для работы с 3D графикой используется WebGL контекст, доступный через getContext('webgl') или getContext('experimental-webgl') в зависимости от браузера. WebGL позволяет создавать сложные 3D сцены и анимации.

```javascript
const canvas = document.getElementById('myCanvas');
const gl = canvas.getContext('webgl');
```

Анимация
Для создания анимаций на Canvas можно использовать таймеры или requestAnimationFrame, который обеспечивает более плавную анимацию, синхронизированную с частотой обновления экрана.

```javascript
function animate() {
    // Код анимации
    requestAnimationFrame(animate);
}

animate();
```

# Знает различия в версиях ECMA

ES5 был выпущен в декабре 2009 года, спустя 10 лет после выхода третьего издания. Среди изменений можно отметить:
- поддержку строгого режима (strict mode);
- аксессоры getters и setters;
- возможность использовать зарезервированные слова в качестве ключей свойств и ставить запятые в конце массива;
- многострочные строковые литералы;
- новую функциональность в стандартной библиотеке;
- поддержку JSON.
  
Версия ES6/ES2015 вышла в июне 2015 года. Это также принесло некую путаницу в связи с названием пакета, ведь ES6 и ES2015 — это одно и то же. С выходом этого пакета обновлений комитет принял решение перейти к ежегодным обновлениям. Поэтому издание было переименовано в ES2015, чтобы отражать год релиза. Последующие версии также называются в соответствии с годом их выпуска. В этом обновлении были сделаны следующие изменения:
- добавлено деструктурирующее присваивание;
- добавлены стрелочные функции;
- в шаблонных строках можно объявлять строки с помощью ` (обратных кавычек). Шаблонные строки могут быть многострочными, также могут интерполироваться;
- let и const — альтернативы var для объявления переменных. Добавлена «временная мертвая зона»;
- итератор и протокол итерации теперь определяют способ перебора любого объекта, а не только массивов. Symbol используется для присвоения итератора к любому объекту;
- добавлены функции-генераторы. Они используют yield для создания последовательности элементов. Функции-генераторы могут использовать yield* для делегирования в другую функцию генератора, кроме этого они могут возвращать - объект генератора, который реализует оба протокола;
- добавлены промисы.

ES2016 (ES7) вышла в июне 2016 года. Среди изменений в этой версии ECMAScript можно отметить:
- оператор возведения в степень **;
- метод Array.prototype.includes, который проверяет, содержится ли переданный аргумент в массиве.

Спустя еще год выходит версия ES2017 (ES8). Данный стандарт получил следующие изменения:
- асинхронность теперь официально поддерживается (async/await);
- «висячие» запятые в параметрах функций. Добавлена возможность ставить запятые в конце списка аргументов функций;
- добавлено два новых метода для работы со строками: padStart() и padEnd(). Метод padStart() подставляет дополнительные символы слева, перед началом строки. А padEnd(), в свою очередь, справа, после конца строки;
- добавлена функция Object.getOwnPropertyDescriptors(), которая возвращает массив с дескрипторами всех собственных свойств объекта;
- добавлено разделение памяти и объект Atomics.
