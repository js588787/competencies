# Знает и понимает, что такое макро и микро - таски

Event Loop является стеком, где хранятся все задачи, которые не вошли в синхронный поток выполнения.
После завершения синхронного потока - задачи начинают выполняться из Event Loop'а. Однако у Event Loop'а тоже есть свои правила:
- Сначала Event Loop проверяет выполнились ли все синхронные задачи
- Потом выполняются все задачи из микротасков
- После выполнения всех микротасков - очередь очищается
- Затем мы берем одну макрозадачу из списка и выполняем ее
- После выполнения мы смотрим нужно ли нам сделать перерисовку страницы
- Если перерисовать страницу нужно - делаем это
- Все снова начинается с первого пункта...

Макрозадачами являются все асинхронные операции:
- setTimeout
- setInterval
- requestAnimationFrame
- Ивенты пользователя
- AJAX-запросы
- Web Workers

В микрозадачи попадают:
- Promise.then()
- MutationObserver callbacks
- IntersectionObserver callbacks
- queueMicrotask(): Функция queueMicrotask() позволяет явно добавить микротаску в очередь микротасок. Это полезно, например, когда нужно гарантировать, что определенный код будет выполнен после всех текущих микротасок, независимо от того, сколько времени займет выполнение этих микротасок.

В задачи отрисовки попадают задачи связанные с отрисовкой и обновлением контента страницы.

# Знает и применяет методы call, apply, bind

Метод call
-
Метод call позволяет вызвать функцию с заданным значением this и аргументами, передаваемыми отдельно. Это означает, что вы можете явно указать, какое значение должно быть использовано вместо this внутри функции.

```javascript
function greet(greeting, punctuation) {
  console.log(`${greeting}, ${this.name}!${punctuation}`);
}

const person = { name: "John" };

// Использование call для изменения контекста this
greet.call(person, "Hello", ".");
// Вывод: Hello, John!. В этом случае this ссылается на объект person
```

Метод apply
-
Похож на call, но принимает два аргумента: первый - это значение this, а второй - массив аргументов, которые будут переданы функции. Это удобно, когда у вас есть много аргументов для передачи.

```javascript
function sum(a, b, c) {
  return a + b + c;
}

console.log(sum.apply(null, [1, 2, 3])); // Вывод: 6
```

Метод bind
-
Создает новую функцию, которая, при вызове, будет использовать указанное значение this. Отличие от call и apply заключается в том, что bind не выполняет функцию сразу, а возвращает ее для последующего вызова. Это полезно, когда вам нужно сохранить определенный контекст this для будущих вызовов функции.

```javascript
function greet(greeting, punctuation) {
  console.log(`${greeting}, ${this.name}!${punctuation}`);
}

const person = { name: "Jane" };
const boundGreet = greet.bind(person);

boundGreet("Hi"); // Вывод: Hi, Jane!
```

Основные моменты
-
- Все три метода (call, apply, bind) используются для изменения значения this внутри функции.
- call и apply выполняют функцию сразу же с заданным this и аргументами, в то время как bind возвращает новую функцию, которую можно вызвать позже.
- Выбор между этими методами зависит от конкретной ситуации и предпочтений разработчика. Важно понимать их различия и применять каждый из них там, где он наиболее подходит.

Знает, как можно «запостить» файл на сервер
Способы работы со стилями (scoped, css modules, БЭМ, глобальные стили) - плюсы и минусы каждого способа
Знает и понимает, что такое макро и микро - таски.
Понимает, как устроены и как манипулировать объектами в JS. Что такое объект-прототип
Знает, как устроены область видимости в JS
Знает, что такое замыкание
Знает о них и применяет методы call, apply, bind
Знает, как реализовать прототипное наследование в JS
Умеет использовать основные инструменты разработчика в браузерах (инспектор html, отладка js, консоль, сеть)
Умеет использовать инструменты для работы с js-кодом (статические анализаторы (jslint), минификаторы)
Знает, что такое reflow/relayout, как оптимизировать работу с DOM
Знает основные css3-селекторы и свойства
Знает что таккое shadow DOM
Знает о возможностях CSS (flex-box и т.д.)
Понимает зачем нужна микроразметка, знает, что такое адаптивная верстка сайта
Знает что такое promise и умеет применять его на практике

# Организация модулей (глобальный объект, CommonJS, UMD, ES modules)

Организация модулей в JavaScript — это ключевой аспект разработки масштабируемых и поддерживаемых приложений. Существует несколько подходов к организации модулей, каждый из которых имеет свои особенности и применяется в зависимости от контекста использования.

Глобальный объект
-

В начале развития JavaScript код часто организовывался через глобальные переменные и функции. Это простой подход, но он быстро становится неприемлемым по мере роста приложения из-за конфликтов имен и сложности управления зависимостями.

```javascript
// Глобальный объект
var myModule = {
  publicMethod: function() {
    // Код метода
  },
  privateMethod: function() {
    // Код метода
  }
};

// Использование
myModule.publicMethod();
```

CommonJS
-

CommonJS — это модульная система, которая была разработана для серверной стороны и широко используется в Node.js. Модули экспортируются с помощью module.exports или exports, а импортируются с помощью require.

```javascript
// myModule.js
const privateMethod = () => {
  // Код метода
};

const publicMethod = () => {
  // Код метода
};

module.exports = publicMethod;

// app.js
const myModule = require('./myModule');
myModule(); // Использование экспортированной функции
```

UMD (Universal Module Definition)
-

UMD позволяет создавать модули, совместимые с различными системами модулей, включая CommonJS и AMD, а также с использованием через тег <script> в браузерах. Это достигается путем определения универсального шаблона, который проверяет доступные среды и экспортирует модуль соответствующим образом.

```javascript
(function (root, factory) {
  if (typeof define === 'function' && define.amd) {
    // AMD
    define([], factory);
  } else if (typeof module === 'object' && module.exports) {
    // CommonJS
    module.exports = factory();
  } else {
    // Глобальная переменная для браузеров
    root.myModule = factory();
  }
}(this, function () {
  // Модуль
  return {};
}));
```

ES Modules
-
ES Modules (ECMAScript Modules) — это стандартная система модулей в JavaScript, введенная в ES6 (ES2015). Она использует ключевые слова import и export для импорта и экспорта функций, объектов или значений между модулями.

```javascript
// myModule.js
export const myFunction = () => {
  // Код функции
};

// app.js
import { myFunction } from './myModule';
myFunction(); // Использование импортированной функции
```

# Конфигурирование сборщиков vite / webpack / esbuild / bun

Конфигурирование сборщиков позволяет адаптировать процесс сборки проекта под конкретные требования и условия.

Vite
-
Vite предлагает простую и интуитивно понятную конфигурацию через файл vite.config.js. Основные возможности включают настройку сервера разработки, оптимизацию для продакшена, настройку плагинов и многое другое.

Пример базовой конфигурации Vite:

```javascript
// vite.config.js
import { defineConfig } from 'vite';

export default defineConfig({
  build: {
    outDir: 'dist', // Папка вывода для продакшена
    assetsDir: '', // Подкаталог для хранения ассетов
    sourcemap: false, // Генерация source map
    minify: 'esbuild', // Минификация с помощью esbuild
    target: 'es2017', // Целевая версия ECMAScript
  },
  server: {
    host: 'localhost', // Хост сервера разработки
    port: 3000, // Порт сервера разработки
    open: true, // Автоматическое открытие браузера
  },
});
```

Webpack
-
Webpack требует более детальной конфигурации через файл webpack.config.js. Он предлагает гораздо больше возможностей для настройки, включая обработку CSS, изображений, а также интеграцию с другими инструментами и плагинами.

Пример базовой конфигурации Webpack:

```javascript
// webpack.config.js
const path = require('path');

module.exports = {
  entry: './src/index.js', // Точка входа
  output: {
    filename: 'main.js', // Имя выходного файла
    path: path.resolve(__dirname, 'dist'), // Путь к папке вывода
  },
  module: {
    rules: [
      {
        test: /\.css$/, // Регулярное выражение для CSS файлов
        use: ['style-loader', 'css-loader'], // Загрузчики для CSS
      },
    ],
  },
  devServer: {
    contentBase: path.join(__dirname, 'dist'), // Корневая директория сервера разработки
    compress: true, // Включение gzip
    port: 9000, // Порт сервера разработки
  },
};
```

esbuild
-
esbuild предлагает простую и быструю сборку проектов с минимальной конфигурацией через файл esbuild.js.

Пример базовой конфигурации esbuild:

```javascript
// esbuild.js
require('esbuild').build({
  entryPoints: ['app.js'],
  bundle: true,
  outfile: 'out.js',
  platform: 'browser',
}).catch(() => process.exit(1))
```

Bun
-
Bun — относительно новый инструмент сборки, который стремится предложить быструю и эффективную сборку проектов. Он предлагает простую конфигурацию через файл bun.config.mjs.

Пример базовой конфигурации Bun:

```javascript
// bun.config.mjs
export default {
  input: 'src/main.ts',
  output: {
    file: 'dist/bundle.js',
    format: 'esm',
  },
  external: [],
  plugins: [],
};
```

# Hoisitng js

Поднятие задумывалось как общий способ мышления о том, как работает контекст выполнения. Однако, hoisting учит, что объявление переменной или функции физически перемещается в начало вашего кода, хотя в действительности этого не происходит. На самом же деле, объявления переменных и функций попадают в память в процессе фазы компиляции, но остаются в коде на том месте, где вы их объявили.
Одним из преимуществ помещения в память объявлений функций до выполнения кода является возможность использовать функцию до её объявления.
Переменные могут быть инициализированы и использованы до их объявления. Однако, они не могут быть использованы без инициализации.

# Работа с SVG (viewport, width, height, цвета, вставка в HTML и тд)

Работа с SVG (Scalable Vector Graphics) включает в себя управление такими концепциями, как viewBox, viewport, width, height, а также применение цветов и вставку SVG в HTML. Эти элементы позволяют контролировать масштабирование, панорамирование и отображение SVG-графики.

ViewBox
-
Этот атрибут определяет координатную систему и область содержимого SVG. Значение viewBox состоит из четырех разделенных пробелами параметров. Первые два параметра контролируют "панорамирование" (перемещение по горизонтали и вертикали), а последние два параметра контролируют "масштабирование". Увеличение первых двух параметров позволяет "панорамировать" вправо или вниз, соответственно. Увеличение последних двух параметров позволяет "увеличивать" масштаб графики.

Viewport
-
Это область просмотра, где отображается SVG-изображение на экране или внутри HTML-документа. Атрибуты width и height элемента SVG определяют размер области просмотра. Если соотношение сторон viewBox и viewport отличается, содержимое SVG масштабируется, чтобы поместиться в область просмотра, сохраняя при этом пропорции. Если соотношения сторон совпадают, содержимое SVG отображается без искажений.

Контроль размера и масштабирования
-
Width и Height: Эти атрибуты элемента SVG контролируют размер области просмотра. Они могут быть заданы в абсолютных единицах (например, пикселях) или в процентах от родительского элемента.

Цвета
-
Цвета в SVG задаются с помощью атрибутов fill (для заливки формы) и stroke (для цвета обводки). Эти атрибуты могут принимать значения в формате RGB, RGBA, HEX, HSL, HSLA и других.

Вставка SVG в HTML
-
SVG может быть встроен напрямую в HTML-код с помощью тега <svg> или вставлен как внешний ресурс с помощью тега <object>, <embed> или <iframe>. При встраивании SVG в HTML, атрибуты viewBox, width и height могут быть использованы для контроля масштабирования и отображения графики.

