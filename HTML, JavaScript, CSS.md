# Знает, как можно «запостить» файл на сервер



# Способы работы со стилями (scoped, css modules, БЭМ, глобальные стили) - плюсы и минусы каждого способа

scoped
-
Это подход к организации CSS стилей в проектах, который обеспечивает изоляцию стилей для отдельных компонентов или частей приложения.

Плюсы
- Изоляция стилей: Scoped стили предотвращают конфликты между стилями разных компонентов, что особенно полезно в больших проектах.
- Улучшение читаемости кода: Разделение стилей на уровне компонентов делает код более организованным и легким для понимания.
- Локальная специфичность: Стили применяются только к соответствующему компоненту, уменьшая риск случайного влияния на другие части приложения.
- Упрощенное отладка: При возникновении проблем с стилями их проще локализовать и исправить.

Минусы
- Повышенная сложность: Использование scoped стилей может усложнить процесс написания и поддержки CSS.
- Ограничения наследования: Изоляция стилей может затруднить создание глобальных стилей или переопределение стилей дочерних элементов.
- Производительность: Генерация уникальных селекторов может увеличить размер CSS-файлов и потенциально повлиять на производительность.
- Необходимость дополнительных инструментов: Для работы со scoped стильями часто требуется использование препроцессоров или сборщиков (например, Webpack).
- Ограниченная совместимость: Некоторые старые браузеры могут не поддерживать все возможности, необходимые для корректной работы scoped стилей.
 

css modules
-
Это подход к организации CSS стилей, который позволяет организовать стили в модулях, таким образом, обеспечивая локальную область видимости, избегая конфликтов имен. 

Плюсы
- Изоляция стилей: каждый компонент имеет свой собственный набор стилей, не влияющих на другие части приложения.
- Уменьшение конфликтов имен: нет необходимости использовать префиксы или длинные идентификаторы классов.
- Гибкость в использовании: можно легко комбинировать стили из разных модулей.
- Чистота кода: каждый компонент содержит все необходимые стили, что упрощает понимание и поддержку

Минусы
- Сложность настройки: требует дополнительных шагов, таких как установка плагинов для сборщика и конфигурация.
- Ограниченная совместимость: не будет работать должным образом с некоторыми старыми браузерами или устаревшими версиями CSS.
- Дополнительная нагрузка на сборку: процесс компиляции CSS Modules может увеличить время сборки проекта, особенно в больших проектах.
- CSS Modules усложняют переиспользование стилей.
  
БЭМ
-
БЭМ представляет собой систему именования и организации селекторов, которая помогает создавать структурированные и переиспользуемые компоненты.

Блок

```javascript
<div class="button">
  <span class="button__text">Кнопка</span>
</div>
```

Элемент

```javascript
<div class="menu">
  <nav class="menu__list">
    <ul class="menu__items">
      <li class="menu__item"><a href="#" class="menu__link">Главная</a></li>
    </ul>
  </nav>
</div>
```

Модификатор

```javascript
<button class="button button_size_l button_color_blue">
  <span class="button__text">Крупная синяя кнопка</span>
</button>
```

Плюсы
- Структура и порядок: БЭМ обеспечивает четкую структуру и порядок именования компонентов.
- Переиспользование: Компоненты легко повторно использовать во многих проектах.
- Четкое разделение: Разделение блоков, элементов и модификаторов помогает в организации кода.
- Гибкость: Методология гибкая и подходит для различных типов проектов.
- Общепринятая система: Большинство российских разработчиков знакомы с БЭМ.

Минусы БЭМ
- Сложность для начинающих: Новая система может быть сложной для новичков.
- Требует соблюдения правил: Необходимо строго следовать принципам БЭМ.
- Может быть слишком жесткой: Некоторые считают ее слишком структурированной.
- Конфликты с другими системами: Может конфликтовать с другими методологиями.

глобальные стили
-

Глобальные стили - это стили CSS, которые определены вне HTML-документа, обычно в отдельном файле или внутри <style> тега в <head> секции HTML.

Плюсы
- Единообразие: Все страницы сайта используют одни и те же стили.
- Организация: Стили отделены от HTML-кода, что улучшает читаемость.
- Повторное использование: Можно легко повторно использовать стили на разных страницах.
- Упрощенная поддержка: Изменения в стилях нужно вносить только в одном месте.

Минусы
- Увеличение времени загрузки: Все стили загружаются вместе с HTML.
- Независимость от контента: Стили могут не соответствовать конкретному контенту.
- Сложности с переиспользованием: Трудно переиспользовать стили для разных контекстов.

# Понимает, как устроены и как манипулировать объектами в JS. Что такое объект-прототип



# Знает, как устроены область видимости в JS

Область видимости (Scope) в JavaScript определяет доступность переменных, функций и объектов в различных частях кода во время выполнения программы. В JavaScript существуют два основных типа областей видимости: глобальная область видимости и локальная область видимости.

Глобальная область видимости
-
Переменные, объявленные вне всех функций или блоков кода, находятся в глобальной области видимости. Они доступны из любой части программы.

```javascript
var globalVar = "Я глобальная переменная";

function exampleFunction() {
    console.log(globalVar); // Доступ к глобальной переменной
}
```

Область видимости функции
-
Переменные, объявленные внутри функции, не доступны за её пределами.

```javascript
function exampleFunction() {
    var localVar = "Я локальная переменная";
    console.log(localVar); // Доступ к локальной переменной
}

exampleFunction(); // Выведет: Я локальная переменная
console.log(localVar); // Ошибка: localVar is not defined
```

Блочная область видимости
-
С введением ES6 в JavaScript появилась возможность создавать блочные области видимости с помощью ключевых слов let и const. Эти переменные доступны только внутри блока кода, в котором они были объявлены.

```javascript
if (true) {
    let blockVar = "Я переменная блочной области видимости";
    console.log(blockVar); // Доступ к blockVar внутри блока
}

console.log(blockVar); // Ошибка: blockVar is not defined
```

Вложенность областей видимости
-

Области видимости могут быть вложенными. Это означает, что внутренняя функция или блок имеет доступ к переменным внешней области видимости, но не наоборот.

```javascript
var outerVar = "Я внешняя переменная";

function outerFunction() {
    var innerVar = "Я внутренняя переменная";
    
    function innerFunction() {
        console.log(outerVar); // Доступ к внешней переменной
        console.log(innerVar); // Доступ к внутренней переменной
    }
    
    innerFunction();
}

outerFunction(); // Внутренняя функция имеет доступ к обоим переменным
console.log(outerVar); // Доступ к внешней переменной
console.log(innerVar); // Ошибка: innerVar is not defined
```

Понимание областей видимости важно для правильного управления переменными и предотвращения ошибок, связанных с их использованием в JavaScript.

# Знает, что такое замыкание

Замыкание (Closure) в JavaScript — это одна из самых мощных и интересных особенностей языка, которая позволяет функции запоминать и сохранять доступ к переменным из своих родительских областей видимости даже после того, как эти переменные больше не доступны в том контексте. Это ведёт к тому, что функция может "запоминать" значения переменных, которые были активны в момент её создания, и продолжать использовать их в будущем, даже если эти переменные уже не существуют в своём первоначальном контексте.

Как работает замыкание:
Когда функция объявлена внутри другой функции, она получает доступ к переменным внешней функции. Если эта внешняя функция возвращает внутреннюю функцию, то возвращённая функция сохраняет ссылку на переменные внешней функции. Это и называется замыканием.

Пример замыкания:

```javascript
function createCounter() {
    let count = 0; // Переменная внешнего контекста

    return function() { // Возвращаемая функция
        count += 1; // Используем переменную из внешнего контекста
        return count;
    };
}

const counter = createCounter();

console.log(counter()); // 1
console.log(counter()); // 2
console.log(counter()); // 3
```

В этом примере функция createCounter создаёт и возвращает другую функцию, которая использует переменную count из своей внешней области видимости. Таким образом, каждый раз, когда мы вызываем возвращённую функцию, она "запоминает" своё состояние благодаря замыканию.

Преимущества замыканий:
- Инкапсуляция: Замыкания позволяют скрыть детали реализации и сделать код более безопасным и удобочитаемым.
- Гибкость: Функции могут быть созданы и использованы в различных контекстах, сохраняя при этом свою функциональность.
- Универсальность: Замыкания используются во многих аспектах JavaScript, начиная от анонимных функций и кончая паттернами проектирования, такими как функциональные компоненты в React.

Недостатки замыканий:
- Высокий расход памяти: Замыкания могут привести к удержанию большого количества данных в памяти, поскольку они "запоминают" все переменные, к которым имели доступ.
- Сложности в отладке: Из-за того, что замыкания работают "за кулисами", отладка кода, использующего замыкания, может стать сложной.
- Замыкания являются фундаментальным понятием в JavaScript и играют ключевую роль в создании мощных и гибких решений. Понимание замыканий позволяет разработчикам писать более продвинутый и эффективный код.

# Знает и понимает, что такое макро и микро - таски

Event Loop является стеком, где хранятся все задачи, которые не вошли в синхронный поток выполнения.
После завершения синхронного потока - задачи начинают выполняться из Event Loop'а. Однако у Event Loop'а тоже есть свои правила:
- Сначала Event Loop проверяет выполнились ли все синхронные задачи
- Потом выполняются все задачи из микротасков
- После выполнения всех микротасков - очередь очищается
- Затем мы берем одну макрозадачу из списка и выполняем ее
- После выполнения мы смотрим нужно ли нам сделать перерисовку страницы
- Если перерисовать страницу нужно - делаем это
- Все снова начинается с первого пункта...

Макрозадачами являются все асинхронные операции:
- setTimeout
- setInterval
- requestAnimationFrame
- Ивенты пользователя
- AJAX-запросы
- Web Workers

В микрозадачи попадают:
- Promise.then()
- MutationObserver callbacks
- IntersectionObserver callbacks
- queueMicrotask(): Функция queueMicrotask() позволяет явно добавить микротаску в очередь микротасок. Это полезно, например, когда нужно гарантировать, что определенный код будет выполнен после всех текущих микротасок, независимо от того, сколько времени займет выполнение этих микротасок.

В задачи отрисовки попадают задачи связанные с отрисовкой и обновлением контента страницы.

# Знает и применяет методы call, apply, bind

Метод call
-
Метод call позволяет вызвать функцию с заданным значением this и аргументами, передаваемыми отдельно. Это означает, что вы можете явно указать, какое значение должно быть использовано вместо this внутри функции.

```javascript
function greet(greeting, punctuation) {
  console.log(`${greeting}, ${this.name}!${punctuation}`);
}

const person = { name: "John" };

// Использование call для изменения контекста this
greet.call(person, "Hello", ".");
// Вывод: Hello, John!. В этом случае this ссылается на объект person
```

Метод apply
-
Похож на call, но принимает два аргумента: первый - это значение this, а второй - массив аргументов, которые будут переданы функции. Это удобно, когда у вас есть много аргументов для передачи.

```javascript
function sum(a, b, c) {
  return a + b + c;
}

console.log(sum.apply(null, [1, 2, 3])); // Вывод: 6
```

Метод bind
-
Создает новую функцию, которая, при вызове, будет использовать указанное значение this. Отличие от call и apply заключается в том, что bind не выполняет функцию сразу, а возвращает ее для последующего вызова. Это полезно, когда вам нужно сохранить определенный контекст this для будущих вызовов функции.

```javascript
function greet(greeting, punctuation) {
  console.log(`${greeting}, ${this.name}!${punctuation}`);
}

const person = { name: "Jane" };
const boundGreet = greet.bind(person);

boundGreet("Hi"); // Вывод: Hi, Jane!
```

Основные моменты
-
- Все три метода (call, apply, bind) используются для изменения значения this внутри функции.
- call и apply выполняют функцию сразу же с заданным this и аргументами, в то время как bind возвращает новую функцию, которую можно вызвать позже.
- Выбор между этими методами зависит от конкретной ситуации и предпочтений разработчика. Важно понимать их различия и применять каждый из них там, где он наиболее подходит.

# Знает, как реализовать прототипное наследование в JS

Для реализации наследования в JavaScript можно использовать функцию ```Object.create()``` или установить свойство prototype для конструктора. Можно это сделать через свойство ```__proto__```, которое устарело, лучше использовать ```Object.getPrototypeOf/Object.setPrototypeOf```.

# Умеет использовать основные инструменты разработчика в браузерах (инспектор html, отладка js, консоль, сеть)

Мы это, вроде, знаем.

# Умеет использовать инструменты для работы с js-кодом (статические анализаторы (jslint), минификаторы)

Статический анализ кода — это методика проверки исходного кода программы на наличие багов, уязвимостей безопасности и несоответствий стилю кодирования без его фактического выполнения. Для JavaScript существует несколько популярных инструментов статического анализа, включая JSLint, ESLint, и Prettier.

Анализаторы можно интегрировать со средами разработки и инструментами сборки и ci/cd для автоматической проверки качества кода.

Минификация — это процесс удаления всех ненужных символов из исходного кода без изменения его функциональности. Это включает в себя удаление пробелов, переносов строк, комментариев и сокращение длинных идентификаторов переменных до коротких. Минификация используется для уменьшения размера файлов JavaScript, CSS и HTML, что приводит к увеличению скорости загрузки веб-страниц.
Минификаторы интегрируются с инструментами сборки. Vite автоматически обрабатывает минификацию JavaScript и CSS в режиме продакшена, используя встроенные плагины и оптимизации. По умолчанию, Vite использует terser для минификации JavaScript и cssnano для минификации CSS.

# Знает, что такое reflow/relayout, как оптимизировать работу с DOM

Reflow (или relayout) — это процесс, при котором браузер пересчитывает позиции и геометрию элементов на веб-странице после внесения изменений, которые влияют на макет страницы или её части. Это может произойти из-за различных действий, таких как добавление, удаление или обновление DOM-узлов, изменение стилей элементов, анимация и даже действия пользователя, такие как изменение размера окна браузера или прокрутка страницы.
Reflow может быть дорогостоящим с точки зрения производительности, особенно на устройствах с ограниченной мощностью процессора. В некоторых случаях reflow может привести к перерасчету всего документа, что существенно замедляет работу интерфейса. Поэтому разработчики стремятся минимизировать количество reflow, оптимизируя изменения DOM и стилизацию элементов.

Repaints (Перерисовка)
-
Repaint возникает в случаях, если были изменены визуальные составляющие элемента, не затрагивающие его разметку. К примеру, opacity, background-color, visibility и outline. Repaint достаточно затратная штука с точки зрения производительности, т.к. браузер должен проверить видимость всех узлом DOM–под одним измененным элементом могут стать видимыми еще один или два.

Reflows (Перекомпановка)
-
Reflow же еще больше воздействуют на производительность. Во время этого процесса происходит перерасчет позиций и размеров всех элементов, что приводит к полной или частичной повторной отрисовке страницы. Изменения в одном элементе могут повлиять на все дочерние, родительские или смежные элементы.

Оба процесса блокируют браузер; и не пользователь, и не ваше веб-приложение не смогут ничего сделать во время reflow и repaint. В крайних случаях CSS эффекты могут затормозить выполнение JavaScript’а. Это одна из причин, почему вы сталкиваетесь с дергающейся прокруткой страницы и неотзывчивым интерфейсом.

Chrome Performance Tool и подобные инструменты позволяют анализировать, какие операции вызывают reflow и repaint, и определять места, где можно улучшить производительность. Это помогает разработчикам визуализировать влияние изменений на производительность и делать обоснованные решения по оптимизации.

Странно, но при попытке считать значения offsetWidth и offsetHeight элемента для их вычисления может быть запущен reflow.

Как минимизировать reflow?
-
- Группируйте изменения стилей и DOM-манипуляции вместе, чтобы минимизировать количество вызываемых reflow.
- Избегайте запроса стилевых свойств, которые могут привести к немедленному reflow, например, offsetHeight, непосредственно перед изменением стилей.
- Используйте CSS-свойства, которые меньше всего влияют на геометрию, например, изменяйте цвет фона вместо изменения границы.
- Рассмотрите возможность использования requestAnimationFrame для группировки анимаций и других изменений, которые могут вызвать reflow.

Полезно знать, в каких случаях запускается reflow:
-
- При добавлении, удалении или изменении видимого элемента DOM. Использование JavaScript для изменения DOM страницы вызывает reflow.
- При добавлении, удалении или изменении CSS стилей. Этот случай похож на первый, изменение стилей напрямую или изменение классов может повлиять на весь макет страницы. Изменив ширину элемента, вы можете повлиять на все элементы того же уровня в DOM и окружающие его элементы.
- CSS3 анимация и свойство transition. Каждый кадр анимации вызывает reflow.
- Использование offsetWidth и OffsetHeight. Странно, но при попытке считать значения offsetWidth и offsetHeight элемента для их вычисления может быть запущен reflow.
- Действия пользователя. И наконец пользователь может вызвать reflow, активировав состояние :hover, при вводе текста в поля, при изменении размера окна, изменении размера шрифта, переключении стилей или шрифтов.

Лучшии практики при создании макета:
- Не используйте инлайновые стили или таблицы в своих макетах!Инлайновые стили срабатывают только после окончательной загрузки HTML и вызывают дополнительный reflow.
- Таблицы снижают производительность, так как парсер не один раз проходится по таблице для вычисления размера ячейки.
- Table-layout: fixed может помочь при представлении табличных данных, так как ширина столбцов будет изменяться в зависимости от содержания строки заголовка.
- Flexbox на главной странице сайта также может привести к падению производительности, так как позиция и размеры ячейки могут измениться после окончательной загрузки HTML.
- Максимально сократите набор правил CSS. Чем меньше правил CSS, тем быстрее reflow. Также по возможности следует избегать сложных CSS селекторов.
- Особенно проблематично если вы используете фреймворк, например, Bootstrap – несколько сайтов используют одновременно больше половины всех стилей. Такие инструменты как UnusedCSS, uCSS, grunt-uncss, и gulp-uncss могут значительно сжать описание стилей и их вес.
- Минимизируйте провалы в DOM. С этим будет чуть сложнее – уменьшите размер вашего DOM и количества узлов в каждой ветке. Чем меньше и мельче ваш документ, тем быстрее будет reflow. Может быть, можно удалить ненужные элементы-обертки, если вы не поддерживаете старые браузеры.
- Как можно сильнее углубите изменения классов в DOM. Сделайте так, что бы при изменении стилей в классах, эти изменения затрагивали как можно более глубокие элементы в DOM (т.е. для тех элементов, у которых нет большого количества дочерних элементов, которые так же имеют большую вложенность). Данный шаг может сократить площадь reflow до пары узлов. По сути, если эффект на дочерние элементы минимален, необходимо применять изменения в классах только для родителей, таких как блоки-обертки.
- Удалите сложную анимацию из потока reflow. Добейтесь того, чтобы анимация применялась к элементам вне DOM. Этого можно достичь с помощью position: absolute или position: fixed. В таком случае изменение размеров и положения элемента не влияют на остальные элементы в документе.
- Изменяйте элементы в скрытом состоянии. Скрытые при помощи display: none элементы не повлекут за собой repaint или reflow во время изменения их стилей. На практике, перед тем, как сделать элемент видимым, старайтесь изменить необходимые для него стили.
- Ограничьте задействованные элементы. Избегайте ситуаций, когда в reflow может быть вовлечено огромное количество элементов. Можно рассмотреть систему вкладок (табов), по клику на таб видимым становится соответствующий блок. Окружающие элементы будут вовлечены в процесс в том случае, если все блоки будут иметь разную высоту. Производительность можно повысить, установив фиксированную высоту для контейнера, или удалив этот элемент.
- Признайте тот факт, что плавность анимации влияет на производительность. Передвигать элемент по пикселю в секунду может смотреться красиво и гладко, но для слабых устройств это затруднительно. Перемещение элемента на 4 пикселя в секунду снижает reflow в 4 раза, и почти незаметно для глаза.
- Анализируйте Repaint с помощью инструментария браузера. Все современные браузеры предоставляют разработчикам набор инструментов, позволяющий отслеживать то, как reflow влияет на производительность. В Blink/Webkit браузерах, таких как Chrome, Safari и Opera это можно сделать, открыв вкладку Сеть и записав активность.

# Знает основные css3-селекторы и свойства

Ну это мы знаем

# Знает что таккое shadow DOM

Один из главных преимуществ Shadow DOM — это изоляция стилей. Стили, определенные внутри Shadow DOM, не затрагивают глобальный DOM и наоборот. Это позволяет создавать компоненты без опасения конфликтов стилей.

```javascript
const shadowRoot = myElement.attachShadow({mode: 'open'});
```

Shadow DOM особенно полезен при создании веб-компонентов. Веб-компоненты — это способ создания пользовательских элементов, которые могут быть использованы в любом месте вашего приложения или даже в других приложениях.

# Знает о возможностях CSS (flex-box и т.д.)

Это мы знаем

# Понимает зачем нужна микроразметка, знает, что такое адаптивная верстка сайта

Микроразметка — это способ организации информации на веб-страницах, который позволяет поисковым системам лучше понимать и интерпретировать содержание страницы. Она используется для улучшения видимости сайта в поисковой выдаче и повышения качества представления информации о сайте в результатах поиска. Существует множество типов микроразметки, которые могут быть разделены на несколько основных категорий:
- Товары и услуги: Микроразметка для описания товаров и услуг, включая цены, наличие на складе, отзывы и рейтинги.
- Локации: Информация о географическом расположении, такие как адреса магазинов, часы работы, контактная информация.
- Персоны: Данные о людях, включая биографические сведения, профессии, достижения.
- События: Информация о мероприятиях, включая даты, места проведения, участников.
- Образование: Данные о курсах, программах обучения, учебных заведениях.
- Рецензии и отзывы: Микроразметка для отзывов о продуктах, услугах, местах и т.д., включая оценки и комментарии.
- Блоги и статьи: Информация о блог-постах и статьях, включая автора, дату публикации, категории и т.д.
- Медиа и контент: Микроразметка для изображений, видео, музыки, включая авторство, лицензионную информацию и т.д.

Форматы микроразметки
-
Самыми распространенными форматами микроразметки являются JSON-LD, Microdata и RDFa. Каждый из этих форматов имеет свои особенности и применяется в зависимости от конкретных потребностей и предпочтений разработчика.

- JSON-LD (JavaScript Object Notation for Linked Data): Представляет данные в формате JSON, легко читаемом как человеком, так и машинами. JSON-LD часто используется для добавления микроразметки непосредственно в HTML-документ.
- Microdata: Поддерживается всеми основными поисковыми системами и позволяет добавлять микроразметку прямо в HTML-атрибуты элементов.
- RDFa (Resource Description Framework in Attributes): Расширяет возможности HTML, добавляя микроразметку через специальные атрибуты.

Выбор формата микроразметки зависит от конкретных требований проекта и предпочтений разработчика. Важно следовать рекомендациям по микроразметке, предоставляемым поисковыми системами, чтобы обеспечить правильное отображение и индексацию информации о сайте.

Основные аспекты адаптивной верстки:
-
- Медиавыражения CSS: Это основной инструмент для реализации адаптивной верстки. Медиавыражения позволяют применять различные стили в зависимости от характеристик устройства, таких как ширина экрана. Например, можно определить разные стили для мобильных устройств, планшетов и настольных компьютеров.
- Резиновые макеты: Резиновая верстка использует относительные единицы измерения (такие как проценты), чтобы элементы на странице могли масштабироваться и подстраиваться под размер экрана. Это обеспечивает гибкость и позволяет контенту адаптироваться к различным размерам экранов.
- Гибкие изображения: Использование изображений, которые автоматически масштабируются и адаптируются к размеру экрана, также является важной частью адаптивной верстки. Это может быть достигнуто с помощью атрибута max-width в CSS, установленного в 100%.
- Прогрессивное улучшение: Эта стратегия предполагает, что базовая версия сайта будет работать даже если некоторые функции или стили не могут быть загружены или применены. Это обеспечивает лучшую совместимость и доступность для всех пользователей.

# Знает что такое promise и умеет применять его на практике

Промис - это специальный объект, который представляет собой результат асинхронной операции, который может быть успешным или неудачным.

Функция, переданная в конструкцию new Promise, называется исполнитель (executor). Когда Promise создаётся, она запускается автоматически. Она должна содержать «создающий» код, который когда-нибудь создаст результат.
Её аргументы resolve и reject – это колбэки, которые предоставляет сам JavaScript.

У объекта promise, возвращаемого конструктором new Promise, есть внутренние свойства:
- state («состояние») — вначале "pending" («ожидание»), потом меняется на "fulfilled" («выполнено успешно») при вызове resolve или на "rejected" («выполнено с ошибкой») при вызове reject.
- result («результат») — вначале undefined, далее изменяется на value при вызове resolve(value) или на error при вызове reject(error).

Создание промиса:

```javascript
const promise = new Promise((resolve, reject) => {
  // Асинхронная операция
  if (success) {
    resolve(result); // Переход в состояние fulfilled
  } else {
    reject(error); // Переход в состояние rejected  
  }
});
```

Обработка результата промиса:

```javascript
promise.then(
  result => { // Выполняется при успешном завершении
    console.log(result);
  },
  error => { // Выполняется при ошибке
    console.error(error);
  }
);
```

Цепочки промисов:

```javascript
doSomething()
  .then(result => doSomethingElse(result))
  .then(finalResult => console.log(finalResult))
  .catch(error => console.error(error));
```

Параллельное выполнение нескольких промисов:

```javascript
Promise.all([promise1, promise2, promise3])
  .then(results => console.log(results))
  .catch(error => console.error(error));
```

# Организация модулей (глобальный объект, CommonJS, UMD, ES modules)

Организация модулей в JavaScript — это ключевой аспект разработки масштабируемых и поддерживаемых приложений. Существует несколько подходов к организации модулей, каждый из которых имеет свои особенности и применяется в зависимости от контекста использования.

Глобальный объект
-

В начале развития JavaScript код часто организовывался через глобальные переменные и функции. Это простой подход, но он быстро становится неприемлемым по мере роста приложения из-за конфликтов имен и сложности управления зависимостями.

```javascript
// Глобальный объект
var myModule = {
  publicMethod: function() {
    // Код метода
  },
  privateMethod: function() {
    // Код метода
  }
};

// Использование
myModule.publicMethod();
```

CommonJS
-

CommonJS — это модульная система, которая была разработана для серверной стороны и широко используется в Node.js. Модули экспортируются с помощью module.exports или exports, а импортируются с помощью require.

```javascript
// myModule.js
const privateMethod = () => {
  // Код метода
};

const publicMethod = () => {
  // Код метода
};

module.exports = publicMethod;

// app.js
const myModule = require('./myModule');
myModule(); // Использование экспортированной функции
```

UMD (Universal Module Definition)
-

UMD позволяет создавать модули, совместимые с различными системами модулей, включая CommonJS и AMD, а также с использованием через тег <script> в браузерах. Это достигается путем определения универсального шаблона, который проверяет доступные среды и экспортирует модуль соответствующим образом.

```javascript
(function (root, factory) {
  if (typeof define === 'function' && define.amd) {
    // AMD
    define([], factory);
  } else if (typeof module === 'object' && module.exports) {
    // CommonJS
    module.exports = factory();
  } else {
    // Глобальная переменная для браузеров
    root.myModule = factory();
  }
}(this, function () {
  // Модуль
  return {};
}));
```

ES Modules
-
ES Modules (ECMAScript Modules) — это стандартная система модулей в JavaScript, введенная в ES6 (ES2015). Она использует ключевые слова import и export для импорта и экспорта функций, объектов или значений между модулями.

```javascript
// myModule.js
export const myFunction = () => {
  // Код функции
};

// app.js
import { myFunction } from './myModule';
myFunction(); // Использование импортированной функции
```

# Конфигурирование сборщиков vite / webpack / esbuild / bun

Конфигурирование сборщиков позволяет адаптировать процесс сборки проекта под конкретные требования и условия.

Vite
-
Vite предлагает простую и интуитивно понятную конфигурацию через файл vite.config.js. Основные возможности включают настройку сервера разработки, оптимизацию для продакшена, настройку плагинов и многое другое.

Пример базовой конфигурации Vite:

```javascript
// vite.config.js
import { defineConfig } from 'vite';

export default defineConfig({
  build: {
    outDir: 'dist', // Папка вывода для продакшена
    assetsDir: '', // Подкаталог для хранения ассетов
    sourcemap: false, // Генерация source map
    minify: 'esbuild', // Минификация с помощью esbuild
    target: 'es2017', // Целевая версия ECMAScript
  },
  server: {
    host: 'localhost', // Хост сервера разработки
    port: 3000, // Порт сервера разработки
    open: true, // Автоматическое открытие браузера
  },
});
```

Webpack
-
Webpack требует более детальной конфигурации через файл webpack.config.js. Он предлагает гораздо больше возможностей для настройки, включая обработку CSS, изображений, а также интеграцию с другими инструментами и плагинами.

Пример базовой конфигурации Webpack:

```javascript
// webpack.config.js
const path = require('path');

module.exports = {
  entry: './src/index.js', // Точка входа
  output: {
    filename: 'main.js', // Имя выходного файла
    path: path.resolve(__dirname, 'dist'), // Путь к папке вывода
  },
  module: {
    rules: [
      {
        test: /\.css$/, // Регулярное выражение для CSS файлов
        use: ['style-loader', 'css-loader'], // Загрузчики для CSS
      },
    ],
  },
  devServer: {
    contentBase: path.join(__dirname, 'dist'), // Корневая директория сервера разработки
    compress: true, // Включение gzip
    port: 9000, // Порт сервера разработки
  },
};
```

esbuild
-
esbuild предлагает простую и быструю сборку проектов с минимальной конфигурацией через файл esbuild.js.

Пример базовой конфигурации esbuild:

```javascript
// esbuild.js
require('esbuild').build({
  entryPoints: ['app.js'],
  bundle: true,
  outfile: 'out.js',
  platform: 'browser',
}).catch(() => process.exit(1))
```

Bun
-
Bun — относительно новый инструмент сборки, который стремится предложить быструю и эффективную сборку проектов. Он предлагает простую конфигурацию через файл bun.config.mjs.

Пример базовой конфигурации Bun:

```javascript
// bun.config.mjs
export default {
  input: 'src/main.ts',
  output: {
    file: 'dist/bundle.js',
    format: 'esm',
  },
  external: [],
  plugins: [],
};
```

# Hoisitng js

Поднятие задумывалось как общий способ мышления о том, как работает контекст выполнения. Однако, hoisting учит, что объявление переменной или функции физически перемещается в начало вашего кода, хотя в действительности этого не происходит. На самом же деле, объявления переменных и функций попадают в память в процессе фазы компиляции, но остаются в коде на том месте, где вы их объявили.
Одним из преимуществ помещения в память объявлений функций до выполнения кода является возможность использовать функцию до её объявления.
Переменные могут быть инициализированы и использованы до их объявления. Однако, они не могут быть использованы без инициализации.

# Работа с SVG (viewport, width, height, цвета, вставка в HTML и тд)

Работа с SVG (Scalable Vector Graphics) включает в себя управление такими концепциями, как viewBox, viewport, width, height, а также применение цветов и вставку SVG в HTML. Эти элементы позволяют контролировать масштабирование, панорамирование и отображение SVG-графики.

ViewBox
-
Этот атрибут определяет координатную систему и область содержимого SVG. Значение viewBox состоит из четырех разделенных пробелами параметров. Первые два параметра контролируют "панорамирование" (перемещение по горизонтали и вертикали), а последние два параметра контролируют "масштабирование". Увеличение первых двух параметров позволяет "панорамировать" вправо или вниз, соответственно. Увеличение последних двух параметров позволяет "увеличивать" масштаб графики.

Viewport
-
Это область просмотра, где отображается SVG-изображение на экране или внутри HTML-документа. Атрибуты width и height элемента SVG определяют размер области просмотра. Если соотношение сторон viewBox и viewport отличается, содержимое SVG масштабируется, чтобы поместиться в область просмотра, сохраняя при этом пропорции. Если соотношения сторон совпадают, содержимое SVG отображается без искажений.

Контроль размера и масштабирования
-
Width и Height: Эти атрибуты элемента SVG контролируют размер области просмотра. Они могут быть заданы в абсолютных единицах (например, пикселях) или в процентах от родительского элемента.

Цвета
-
Цвета в SVG задаются с помощью атрибутов fill (для заливки формы) и stroke (для цвета обводки). Эти атрибуты могут принимать значения в формате RGB, RGBA, HEX, HSL, HSLA и других.

Вставка SVG в HTML
-
SVG может быть встроен напрямую в HTML-код с помощью тега <svg> или вставлен как внешний ресурс с помощью тега <object>, <embed> или <iframe>. При встраивании SVG в HTML, атрибуты viewBox, width и height могут быть использованы для контроля масштабирования и отображения графики.

