# Quick sort (быстрая сортировка)
Cуть алгоритма заключается в разделении массива на два под-массива, средней линией считается элемент, который находится в самом центре массива. 
В ходе работы алгоритма элементы, меньшие чем средний будут перемещены в лево, а большие в право. Такое же действие будет происходить рекурсивно и с под-массива, они будут разделяться на еще два под-массива до тех пор, пока не будет чего разделать (останется один элемент). На выходе получим отсортированный массив. 
Сложность алгоритма зависит от входных данных и в лучшем случае будет равняться O(n×2log2n). В худшем случае O(n^2). Существует также среднее значение, это O(n×log2n).

Когда применять
- При работе с большими наборами данных, где важна производительность.
- Когда требуется эффективное использование памяти (в среднем требует O(log n) дополнительной памяти).
- В ситуациях, когда порядок равных элементов не имеет значения (алгоритм по умолчанию неустойчивый).
Однако, быстрая сортировка может быть менее эффективной для уже отсортированных или почти отсортированных массивов, так как в худшем случае ее сложность достигает O(n^2).

```javascript
function quickSort(arr) {
  if (arr.length <= 1) {
    return arr;
  }

  const pivotIndex = Math.floor(arr.length / 2);
  const pivot = arr[pivotIndex];

  const left = [];
  const right = [];

  for (let i = 0; i < arr.length; i++) {
    if (i === pivotIndex) continue;

    if (arr[i] <= pivot) {
      left.push(arr[i]);
    } else {
      right.push(arr[i]);
    }
  }

  return [...quickSort(left), pivot, ...quickSort(right)];
}
```

Объяснение алгоритма
- Если массив содержит один или ноль элементов, он уже отсортирован, поэтому возвращаем его как есть.
- Выбираем опорный элемент (pivot).
- Создаем два подмассива: left для элементов меньше pivot и right для элементов больше pivot.
- Рекурсивно сортируем left и right.
- Объединяем результаты: [...quickSort(left), pivot, ...quickSort(right)].

Особенности реализации
- Выбор опорного элемента влияет на производительность. В данном примере мы выбираем средний элемент, но существуют более эффективные стратегии.
- Алгоритм неустойчив по умолчанию, но можно модифицировать для устойчивости.
- Для небольших подмассивов (обычно менее 10 элементов) рекомендуется использовать простую сортировку вставками для оптимизации.

Лучшие практики
- Используйте случайное выбор опорного элемента для предотвращения худшего случая O(n^2).
- Применяйте "оптимизацию Хоара" для улучшения производительности.
- Для больших наборов данных рассмотрите возможность использования гибридных алгоритмов (например, Introsort).

Быстрая сортировка - это мощный инструмент для сортировки больших объемов данных. Она эффективна в большинстве случаев, но требует осторожности при работе с уже отсортированными данными или когда важен порядок равных элементов.
