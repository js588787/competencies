# Может объяснить и использовать на практике стек, очередь, дек, массив, список (и связный список), ассоциативный массив (и хеш-таблица)

Стек и очередь - это два основных типа структур данных, используемых в программировании. Они имеют принципиально разные способы организации и обработки элементов:

Стек (Stack)
-
Особенности:
- Последний вошел - первый вышел (LIFO - Last In, First Out)
- Элементы добавляются и удаляются с одного конца
- Новый элемент помещается поверх предыдущего

Основные операции:
- Push (добавление элемента на вершину стека)
- Pop (удаление элемента с вершины стека)
- Peek (посмотреть верхний элемент без удаления)

Пример реализации на JavaScript:
```javascript
class Stack {
    constructor() {
        this.items = [];
    }
    
    push(item) {
        this.items.push(item);
    }
    
    pop() {
        return this.items.pop();
    }
    
    peek() {
        return this.items[this.items.length - 1];
    }
}

const stack = new Stack();
stack.push(1);
stack.push(2);
console.log(stack.pop()); // 2
console.log(stack.peek()); // 1
```

Очередь (Queue)
-

Особенности:
- Первый вошел - первый вышел (FIFO - First In, First Out)
- Элементы добавляются в конец и удаляются из начала
- Новый элемент помещается в конец очереди

Основные операции:
- Enqueue (добавление элемента в конец очереди)
- Dequeue (удаление элемента из начала очереди)
- Peek (посмотреть первый элемент без удаления)

Пример реализации на JavaScript:
```javascript
class Queue {
    constructor() {
        this.items = [];
    }
    
    enqueue(item) {
        this.items.push(item);
    }
    
    dequeue() {
        return this.items.shift();
    }
    
    peek() {
        return this.items[0];
    }
}

const queue = new Queue();
queue.enqueue(1);
queue.enqueue(2);
console.log(queue.dequeue()); // 1
console.log(queue.peek()); // 2
```

Ключевые различия
-
Порядок обработки элементов:
- Стек: Последний добавленный элемент обрабатывается первым
- Очередь: Первый добавленный элемент обрабатывается первым

Местоположение добавления и удаления:
- Стек: Все операции выполняются с одного конца (вершина)
- Очередь: Добавление в конец, удаление из начала

Применение:
- Стек часто используется для обратной отслеживаемости (например, история браузера)
- Очередь обычно применяется при необходимости обработки задач в порядке их поступления

Дек
-
Дек (deck) в программировании - это специализированная коллекция элементов, которая позволяет добавлять и удалять элементы с обеих сторон.
Основные характеристики дека:
- Элементы могут добавляться и удаляться с обоих концов (начала и конца).
- Дек может работать как очередь (FIFO - First-In-First-Out) или как стек (LIFO - Last-In-First-Out).
- Дек может быть ограниченным или неограниченным по размеру.

Дек используют при необходимости эффективного добавления и удаления элементов с обоих концов списка.

```javascript
class Deck {
  constructor() {
    this.items = [];
  }

  // Добавляет элемент в начало дека
  pushFront(item) {
    this.items.unshift(item);
  }

  // Добавляет элемент в конец дека
  pushBack(item) {
    this.items.push(item);
  }

  // Удаляет элемент из начала дека
  popFront() {
    return this.items.shift();
  }

  // Удаляет элемент из конца дека  
  popBack() {
    return this.items.pop();
  }

  // Возвращает первый элемент дека без удаления
  peekFront() {
    return this.items[0];
  }

  // Возвращает последний элемент дека без удаления
  peekBack() {
    return this.items[this.items.length - 1];
  }

  // Проверяет, пуст ли дек
  isEmpty() {
    return this.items.length === 0;
  }

  // Возвращает размер дека
  size() {
    return this.items.length;
  }
}
```

Связный список
-
Linked list - это структура данных, состоящая из набора узлов, каждый из которых содержит некоторое значение и ссылку (указатель) на следующий узел в списке. Основные характеристики списка:
- Узлы связаны друг с другом через ссылки.
- Каждый узел содержит данные и указатель на следующий узел.
- Список может быть односвязным или двусвязным.

```javascript
class Node {
  constructor(value) {
    this.value = value;
    this.next = null;
  }
}

class LinkedList {
  constructor() {
    this.head = null;
    this.tail = null;
    this.length = 0;
  }

  // Добавляет новый узел в начало списка
  prepend(value) {
    const newNode = new Node(value);
    if (this.length === 0) {
      this.head = this.tail = newNode;
    } else {
      newNode.next = this.head;
      this.head = newNode;
    }
    this.length++;
  }

  // Добавляет новый узел в конец списка
  append(value) {
    const newNode = new Node(value);
    if (this.length === 0) {
      this.head = this.tail = newNode;
    } else {
      this.tail.next = newNode;
      this.tail = newNode;
    }
    this.length++;
  }

  // Удаляет первый узел со значением value
  remove(value) {
    if (!this.head) return;

    if (this.head.value === value) {
      this.head = this.head.next;
      this.length--;
      return;
    }

    let current = this.head;
    while (current.next) {
      if (current.next.value === value) {
        current.next = current.next.next;
        this.length--;
        return;
      }
      current = current.next;
    }
  }

  // Находит первый узел со значением value
  find(value) {
    let current = this.head;
    while (current) {
      if (current.value === value) return current;
      current = current.next;
    }
    return null;
  }

  // Возвращает массив всех значений в списке
  toArray() {
    const result = [];
    let current = this.head;
    while (current) {
      result.push(current.value);
      current = current.next;
    }
    return result;
  }

  // Возвращает строковое представление списка
  toString() {
    return this.toArray().join(' -> ');
  }
}
```

Ассоциативный массив (также известный как словарь или хеш-таблица)  
-
Ассоциативный массив - это коллекция элементов, где каждый элемент состоит из пары "ключ-значение". Ключи уникальны и используются для идентификации и доступа к соответствующим значениям.

Когда использовать
- Когда нужно быстро искать данные по определенному идентификатору
- При работе с конфигурационными данными
- Для представления объектов с динамическими свойствами
- В ситуациях, когда порядок элементов не важен

В JavaScript ассоциативный массив реализован как объект (Object).

# Понимает понятие устойчивости сортировки

Устойчивость сортировки - важное свойство, которое следует учитывать при выборе и реализации алгоритмов сортировки, особенно когда порядок равных элементов имеет значение для дальнейшей обработки или представления данных.
Устойчивая сортировка - это такая сортировка, которая сохраняет относительный порядок равных элементов. Другими словами, если два элемента были расположены в определенном порядке до сортировки и имели одинаковое значение, то после сортировки их порядок останется прежним.

Преимущества устойчивости
- Сохранение дополнительной информации: Устойчивая сортировка позволяет сохранять дополнительные характеристики элементов, которые не учитываются при основной сортировке.
- Предсказуемость результата: Пользователи могут ожидать определенный порядок элементов даже при равенстве ключей сортировки.
- Упрощение дальнейшей обработки данных: Устойчивость может быть полезна при последующей обработке или группировке данных.

Некоторые популярные алгоритмы сортировки, обладающие устойчивостью:
- Merge Sort
- Insertion Sort
- Bubble Sort
- Counting Sort
- Radix Sort

Алгоритмы без устойчивости
- Quick Sort (хотя можно модифицировать для устойчивости)
- Heap Sort
- Selection Sort

```Array.prototype.sort()``` гарантирует устойчивую сортировку. Обычно, этот метод реализует либо быструю сортировку, либо ее вариации.

# Знает алгоритмы сортировки и их временную сложность
- [быстрая сортировка](https://github.com/js588787/competencies/blob/main/alg/sort/quick.md)
- [сортировка пузырьком]()




# Знает алгоритмы поиска и их временную сложность: поиск в глубину, поиск в ширину
# Понимает плюсы и минусы использования тех или иных базовых структур данных (размер памяти, время выполнения операций с данными, в чем разница между массивами и связными списками в этом плане).
# Может объяснить, как реализовать хэш-таблицы и как обработать коллизии. Приоритетные очереди и способы их реализации, и т.д.
# Может объяснить и использовать на практике граф, дерево
# Знает структуры деревьев: B+ дерево, двоичное дерево поиска, ориентированный граф, куча, двоичная куча, биноминальная куча
# Понимает понятие вычислительной сложности алгоритма, понятие оценки алгоритма сортировки (оценка временной сложности и сложности по памяти)

# Знает алгоритмы сортировки и их временную сложность
- [сортировка выбором](https://github.com/js588787/competencies/blob/main/alg/sort/selection.md)
- [сортировка слиянием]()
- [сортировка вставками]()
- [блочная сортировка]()
- [поразрядная сортировка]()

# Знает алгоритмы поиска и их временную сложность: бинарный поиск, линейный поиск, кратчайшее расстояние по алгоритму Дейкстры (с использованием двоичной кучи) как очередь с приоритетом

[Шпаргалка по сложености](https://habr.com/ru/articles/188010/)
