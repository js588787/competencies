# Знает жизненный цикл Vue-компонентов

```onBeforeMount, onMounted, onBeforeUpdate, onUpdated, onBeforeUnmount, onUnmounted, onErrorCaptured, onRenderTracked, onRenderTriggered, onActivated, onDeactivated```

```onErrorCaptured``` - будет вызван при обнаружении ошибки, распространяющейся от дочернего компонента
```onRenderTracked``` - позволяет отследить момент когда именно изменились данные, вызвавшие перерисовку
```onRenderTriggered``` - вызываться, когда реактивная зависимость запускает повторный запуск эффекта рендеринга компонента
```onActivated``` - будет вызван после вставки экземпляра компонента в DOM как часть дерева, кэшированного <KeepAlive>
```onServerPrefetch``` - регистрирует асинхронную функцию, которая должна быть разрешена до того, как экземпляр компонента будет отрисован на сервере

# Знает, что такое vue-router

Vue Router — это официальный маршрутизатор для Vue.js, который позволяет создавать одностраничные приложения (SPA) с навигацией между различными маршрутами. Vue Router предоставляет мощные возможности для управления URL-адресами и представлениями в приложении, делая навигацию между страницами или компонентами более плавной и эффективной.

Основные возможности Vue Router:
- Маршрутизация: Определение маршрутов и связывания их с компонентами или страницами.
- Глубокое связывание: Связывание маршрутов с компонентами на основе пути URL, что позволяет создавать сложные SPA.
- Параметры маршрута: Поддержка параметров в URL для динамической навигации.
- Переадресация и отказ: Управление перенаправлением пользователей между маршрутами.
- Защита маршрутов: Автоматическое разрешение или запрет доступа к маршрутам на основе условий.
- Lazy Loading: Загрузка компонентов маршрутов по мере необходимости для улучшения производительности.
- История браузера: Управление историей браузера для навигации назад и вперед.

# Для чего нужен key в компонентах
Атрибут key в Vue.js играет критически важную роль в оптимизации процесса рендеринга, особенно при работе с директивой v-for для перебора массивов. Каждый элемент в списке должен иметь уникальный key, который помогает Vue идентифицировать каждый элемент списка и эффективно обновлять DOM при изменении данных.

Зачем нужен key?
Оптимизация рендеринга: Когда данные списка изменяются (например, элементы добавляются, удаляются или перемещаются), Vue использует key для определения, какие элементы нужно перерисовать, а какие оставить без изменений. Это значительно улучшает производительность, особенно при работе с большими списками.
Предотвращение ошибок: Без уникальных ключей Vue может смешивать свойства элементов при изменении массива, что приводит к неправильному отображению данных.

# Какие есть препроцессоры и как их использовать (Sass/SCSS, PostCSS)

Препроцессоры CSS, такие как Sass/SCSS и PostCSS, позволяют расширять стандартный синтаксис CSS, добавляя новые возможности и функции, что делает процесс написания стилей более мощным и удобным. Код, написанный с использованием препроцессоров компилируется в css, это можно доверить сборщикам.

Sass/SCSS
-
Sass (Syntactically Awesome Stylesheets) — это препроцессор CSS, который добавляет множество новых возможностей, таких как переменные, миксины, наследование, импорт и многое другое. Sass поддерживает два основных синтаксиса: оригинальный Sass (с использованием Ruby) и SCSS (Syntactically Awesome Stylesheets), который является более современным и ближе к синтаксису CSS.

Основные концепции SCSS:
Переменные — позволяют определить значения, которые можно повторно использовать в стилевой таблице. Это особенно полезно для цветов, шрифтов и других часто используемых значений.
```css
$primary-color: #3498db;

body {
  background-color: $primary-color;
}
```

Миксины — это группы деклараций, которые можно повторно использовать в различных селекторах. Миксины могут принимать аргументы, что делает их очень гибкими.
```css
@mixin transform($property) {
  -webkit-transform: $property;
  -ms-transform: $property;
  transform: $property;
}

.box { 
  @include transform(rotate(30deg)); 
}
```

Наследование - позволяет одному селектору наследовать свойства другого селектора. Это упрощает повторное использование стилей.
```css
.base-text {
  color: $primary-color;
}

.text-large {
  @extend .base-text;
  font-size: 20px;
}
```

Импорт - позволяет включать стили из других файлов SCSS. Это удобно для организации больших проектов.
```css
@import 'variables';
@import 'mixins';
Инкременты и операции
SCSS поддерживает математические операции и инкременты, что позволяет создавать динамические значения.

$font-size-base: 16px;

.container {
  font-size: $font-size-base * 1.5;
}
```

Кондициональные операторы - SCSS поддерживает условные операторы, такие как if, else if и else, что позволяет создавать динамические стили.
```css
$theme: dark;

body {
  background-color: $theme == dark ? black : white;
}
```

PostCSS
-
Это инструмент для трансформации CSS с помощью JavaScript-плагинов, который позволяет модифицировать CSS перед его применением в браузере. Он предлагает гибкую систему для расширения возможностей CSS, что делает его мощным инструментом для современной веб-разработки. Вот ключевые аспекты, которые стоит знать о PostCSS:
- Трансформация CSS: PostCSS преобразует CSS в абстрактное синтаксическое дерево (AST), что позволяет анализировать и модифицировать его с помощью JavaScript-плагинов.
- Экосистема плагинов: PostCSS поддерживает широкий спектр плагинов, включая Autoprefixer для добавления префиксов, Stylelint для статической проверки стилей, CSSNano для минификации CSS, и многие другие.
- Независимость от спецификаций CSS: В отличие от препроцессоров, таких как Sass или Less, PostCSS не привязан к конкретным спецификациям CSS. Это означает, что он может работать с любым CSS, независимо от его структуры или синтаксиса.
- Интеграция с другими технологиями: PostCSS может использоваться вместе с препроцессорами, такими как Sass, Less, Stylus, или как альтернатива им, поскольку он обладает всеми необходимыми функциями для самостоятельного использования.
- PostCSS требует настройки в конфиге postcss.config.js.

# Знает, для чего нужна Pinia, как ее применять на проекте

Pinia — это библиотека управления состоянием для Vue.js, созданная с целью предложить более простой и мощный интерфейс для работы с состоянием приложения по сравнению с Vuex. Она была разработана с учетом обратной связи от сообщества Vue и стремится обеспечить лучшую производительность, более простой API и лучшую интеграцию с Vue 3.

Основные характеристики Pinia:
- Простота использования: Pinia предлагает простой и интуитивно понятный API для управления состоянием, что делает его доступным даже для начинающих разработчиков.
- Производительность: Pinia оптимизирован для работы с Vue 3 Composition API, что позволяет достигать лучшей производительности по сравнению с Vuex.
- Модульность: Pinia позволяет создавать отдельные хранилища состояния для различных частей приложения, что упрощает тестирование и поддержку кода.
- Интеграция с Vue Devtools: Pinia хорошо интегрируется с Vue Devtools, предоставляя удобные инструменты для отладки состояния приложения.
- Поддержка TypeScript: Pinia поддерживает TypeScript, что делает его идеальным выбором для проектов на TypeScript.

Основные концепции Pinia:
- Хранилища: В Pinia состояние приложения организуется в хранилища, каждое из которых имеет уникальный идентификатор. Хранилища могут содержать состояние, действия и getters.
- Actions: Actions позволяют изменять состояние хранилища. Они могут быть асинхронными и могут вызывать другие actions.
- Getters: Getters предоставляют способ вычислять и возвращать значения на основе состояния хранилища.
- Pinia Plugin System: Pinia поддерживает плагины, что позволяет расширять его функциональность.

# Знает для чего нужны: axios, window.fetch

Axios и window.fetch являются популярными методами для выполнения HTTP-запросов в JavaScript, но они имеют ряд отличий в своей реализации и возможностях. Эти различия влияют на выбор между ними в зависимости от конкретных требований проекта.

Axios
-
Это библиотека, созданная для выполнения HTTP-запросов. Она предоставляет более высокоуровневый API по сравнению с fetch и включает в себя множество дополнительных функций, которые делают ее удобной для использования в различных сценариях.

Основные особенности Axios:
- Более дружелюбный API: Axios предоставляет более простой и понятный интерфейс для выполнения запросов и обработки ответов.
- Обработка ошибок: Axios автоматически преобразует ошибки HTTP в исключения, что упрощает обработку ошибок.
- Преобразование данных: Axios позволяет легко преобразовывать ответы в JSON и отправлять запросы с JSON-данными без необходимости явного указания типа данных.
- Отмена запросов: Axios поддерживает отмену запросов, что может быть полезно для предотвращения ненужных сетевых запросов.
- Прогресс-бар: Axios поддерживает прогресс-бары для загрузки файлов, что может быть полезно при загрузке больших файлов.

Window.fetch
-
Это нативный метод для выполнения HTTP-запросов, доступный в современных браузерах. Он является частью Fetch API и предназначен для замены XMLHttpRequest.

Основные особенности fetch:
- Promise-based: fetch возвращает Promise, что делает его асинхронным и позволяет использовать современные возможности ES6 для работы с асинхронностью.
- Стандартный API: fetch является частью стандарта и доступен в большинстве современных браузеров без необходимости использования сторонних библиотек.
- Отсутствие обработки ошибок: В отличие от Axios, fetch не преобразует статусы HTTP ошибок (например, 404 или 500) в исключения. Вместо этого, эти статусы считаются успешными, и для их обработки необходимо проверять свойство ok объекта Response.
- Меньше функциональности: fetch предоставляет базовые возможности для выполнения HTTP-запросов и получения ответов, но не включает некоторые продвинутые функции, доступные в Axios.

# Знает что нового принес composition API

Composition API, введенная в Vue 3, представляет собой радикальное улучшение над предыдущим подходом к организации кода в Vue.js, известным как Options API. Composition API предлагает более гибкий и мощный способ создания компонентов, позволяя разработчикам лучше структурировать и переиспользовать логику компонентов. Вот что принесло Composition API в Vue.js:
- Переиспользование логики: Composition API позволяет создавать "composables" — функции, которые группируют и переиспользуют логику компонентов. Это решает проблемы, связанные с переиспользованием логики в Options API, например, с миксинами, и делает код более чистым и модульным.
- Более гибкая организация кода: API основано на функциональном подходе, что позволяет более гибко организовывать код внутри компонентов. Разработчики могут выбирать, какие части логики должны быть доступны в шаблоне компонента, а какие остаются скрытыми внутри setup() функции.
- Улучшенная поддержка TypeScript: Composition API тесно интегрирована с TypeScript, что делает Vue.js более дружелюбным к TypeScript разработчикам. Функции реактивности, такие как ref() и reactive(), автоматически генерируют типы, что уменьшает количество ручной работы и увеличивает безопасность типов.
- Меньший размер пакета и меньше накладных расходов: Использование Composition API может привести к меньшему размеру конечного пакета и меньше накладных расходов по сравнению с Options API, благодаря более эффективному использованию возможностей Vue 3.

Отношение к Options API
-
Options API остается важной частью Vue и не планируется устаревание. Composition API предназначена для более крупномасштабных проектов, где её преимущества становятся очевидными, в то время как Options API продолжает оставаться надежным выбором для многих низко- и средней сложности сценариев.

Использование обоих API в одном компоненте
-
Разработчики могут использовать и Composition API, и Options API в одном компоненте, что позволяет постепенно переходить на новую систему API или интегрировать новые функции с уже существующим кодом на Options API.

Composables в контексте Vue.js и Composition API — это функции, которые помогают организовать и переиспользовать логику компонентов. Они представляют собой способ группировки и повторного использования функциональности между компонентами, что делает код более чистым, легче для чтения и поддержки. Composables используются для решения общих задач, таких как управление состоянием, выполнение асинхронных запросов, взаимодействие с внешними сервисами и многое другое.

Основные характеристики composables:
- Переиспользуемость: Composables могут быть легко импортированы и использованы в любом компоненте, что позволяет избежать дублирования кода.
- Чистота и модульность: Поскольку composables фокусируются на выполнении одной конкретной задачи, они помогают организовать код более четко и модульно.
- Реактивность: Composables могут использовать реактивные функции Vue, такие как reactive и ref, чтобы обеспечить реактивность данных внутри компонентов.

Пример создания и использования composable:
Допустим, у нас есть задача выполнения асинхронного запроса к API. Мы можем создать composable для этой задачи:
```javascript
// useApiRequest.js
import { ref } from 'vue';

export function useApiRequest(url) {
  const data = ref(null);
  const error = ref(null);

  async function fetchData() {
    try {
      const response = await fetch(url);
      data.value = await response.json();
    } catch (err) {
      error.value = err;
    }
  }

  return { data, error, fetchData };
}
```

Преимущества использования composables:
- Уменьшение дублирования кода: Composables позволяют централизованно решать одни и те же задачи, что снижает дублирование кода.
- Улучшение читаемости: Чистые и модульные composables делают код более понятным и легким для чтения.
- Лучшая поддержка TypeScript: Composables могут быть легко типизированы с использованием TypeScript, что улучшает безопасность типов и автодополнение в редакторах кода.

# Зачем нужен Slot

Тут все понятно. Добавлю про scoped slots

В обычном слоте контент определяется в родительском компоненте и вставляется в дочерний. Слот с ограниченной областью видимости работает аналогично, но также позволяет дочернему компоненту передавать данные обратно в родительский через слот. Это достигается путем добавления атрибута v-slot к тегу <template> в родительском компоненте, который принимает значения, переданные из дочернего компонента.

```html
<!-- Дочерний компонент -->
<div class="child-component">
  <slot name="header" :user="user"></slot>
</div>

<!-- Родительский компонент -->
<ChildComponent>
  <template v-slot:header="slotProps">
    <h1>{{ slotProps.user.name }}</h1>
    <p>Age: {{ slotProps.user.age }}</p>
  </template>
</ChildComponent>
```

# Отслеживание изменение объектов ( watch и его аргументы)

Типы источников watch​
-
Первым аргументом watch могут быть различные типы реактивных "источников": это может быть ref (включая вычисляемые refs), реактивный объект, геттер-функция или массив из нескольких источников:

```javascript
const x = ref(0)
const y = ref(0)

// одиночный ref
watch(x, (newX) => {
  console.log(`x is ${newX}`)
})

// геттер
watch(
  () => x.value + y.value,
  (sum) => {
    console.log(`сумма x + y равна: ${sum}`)
  }
)

// массив из нескольких источников
watch([x, () => y.value], ([newX, newY]) => {
  console.log(`x равен ${newX} и y равен ${newY}`)
})
```

Аргументы функции обратного вызова
-
Функция обратного вызова в watch, которую вы определяете для отслеживания изменения свойства, может принимать до трех аргументов:
- newValue: Новое значение свойства.
- oldValue: Старое значение свойства.
- instance: Экземпляр компонента, в котором происходит отслеживание. Этот аргумент доступен начиная с Vue 3 и позволяет вам получить доступ к другим свойствам и методам компонента внутри функции обратного вызова.

Дополнительные опции для watch
-
Vue также предоставляет дополнительные опции для более тонкой настройки отслеживания изменений:
- deep: Если установлено значение true, будет отслеживаться глубокое изменение объектов и массивов. Это полезно, когда вам нужно реагировать на изменения вложенных свойств.
- immediate: Если установлено значение true, функция обратного вызова будет выполнена сразу после создания наблюдателя, а не только при изменении значения.

Обратный вызов наблюдателя будет выполняться всякий раз, когда изменяется отслеживаемый источник. Если вы хотите, чтобы обратный вызов запускался только один раз при изменении источника, используйте параметр once: true.

watchEffect()
-
Позволяет нам немедленно выполнить побочный эффект, автоматически отслеживая реактивные зависимости. 

```javascript
watchEffect(async () => {
  const response = await fetch(
    `https://jsonplaceholder.typicode.com/todos/${todoId.value}`
  )
  data.value = await response.json()
})
```

Здесь обратный вызов будет запущен немедленно, нет необходимости указывать ```immediate: true```. Во время его выполнения он будет автоматически отслеживать todoId.value как зависимость (аналогично вычисляемым свойствам). Всякий раз, когда ```todoId.value``` изменяется, обратный вызов будет запущен снова. С помощью ```watchEffect()``` нам больше не нужно явно передавать todoId в качестве источника.

watch vs. watchEffect​
-

```watch``` и ```watchEffect``` позволяют нам реактивно выполнять побочные эффекты. Их основное различие заключается в том, как они отслеживают свои реактивные зависимости:
- ```watch``` отслеживает только явно указанный источник. Он не будет отслеживать ничего, к чему обращаются внутри обратного вызова. Кроме того, обратный вызов срабатывает только тогда, когда источник действительно изменился.
- ```watch``` отделяет отслеживание зависимости от побочного эффекта, давая нам более точный контроль над тем, когда должен сработать обратный вызов.
- ```watchEffect```, с другой стороны, объединяет отслеживание зависимостей и побочный эффект в одну фазу. Он автоматически отслеживает каждое реактивное свойство, доступ к которому осуществляется во время его синхронного выполнения. Это более удобно и обычно приводит к более лаконичному коду, но делает его реактивные зависимости менее явными.

# Привести примеры типов: примитивы, объектные типы, иные (any, object)

Примитивные типы в TypeScript включают в себя:
- string
- number
- boolean
- null
- undefined
- symbol
- bigint

Объектные типы
Объектные типы включают в себя интерфейсы, классы и литеральные типы объектов.

Интерфейсы
Интерфейсы определяют контракты для объектов.

Классы
Классы используются для создания объектов с определенными свойствами и методами.

Литеральные типы объектов
Литеральные типы позволяют определить конкретную форму объекта.

Специальные типы
- any. Тип any используется, когда вы хотите отключить проверку типов для определенного значения.
- unknown. Представляет собой безопасную альтернативу типу any. Все типы могут быть присвоены переменной типа unknown. Переменная типа unknown может быть присвоена только переменным типа unknown или any. На переменной типа unknown нельзя выполнять никаких операций без предварительной проверки или утверждения типа.
- object. Тип object представляет собой более строгую альтернативу any для случаев, когда вам нужно работать с объектами, но вы не знаете их конкретную форму.

Отличия object и unknown
Присваивание значений
unknown: Любое значение можно присвоить переменной типа unknown.
object: Только объектные значения можно присвоить переменной типа object. Примитивные типы нельзя присвоить напрямую.

Использование свойств и методов
unknown: Нельзя использовать свойства или вызывать методы без предварительной проверки типа.
object: Можно использовать свойства и методы, определенные для всех объектов (например, toString()), но доступ к специфическим свойствам конкретных объектов требует дополнительной проверки.

Наследование
unknown: Не является супертипом ни для каких других типов.
object: Является супертипом для всех пользовательских объектов.

Проверка типа
unknown: Требует строгой проверки типа перед использованием.
object: Может потребовать проверку типа, но это менее строгое требование, чем для unknown.

# Зачем нужен оператор keyof

Оператор keyof позволяет получить тип ключей объекта или интерфейса в виде объединения строковых литералов.
```javascript
interface Person {
  name: string;
  age: number;
  location: string;
}

type PersonKeys = keyof Person; // тип: "name" | "age" | "location"
```

- Работает только на уровне типов, поэтому используйте его в сочетании с typeof, когда нужно получить тип значения.
- Используйте keyof для создания более безопасных и гибких типов, особенно при работе с дженериками.

# Поиск типов (Lookup Types)
Lookup Types (или Indexed Access Types) в TypeScript - это мощное средство для получения типов свойств объекта или элементов массива. Они позволяют динамически обращаться к типам на основе строковых литералов или числовых индексов.
Lookup Type имеет вид Type['key'], где Type - это тип объекта или массива, а 'key' - это строковый литерал или числовой индекс.

```javascript
interface IInterfaceType {
  p1: number;
  p2: string;
}
let union: IInterfaceType['p1' | 'p2']; // union: number | string
```
----------

# Перегрузка функций в TS

Перегрузка функций в TypeScript позволяет определять несколько сигнатур для одной и той же функции, каждая из которых описывает различные варианты использования этой функции.
```javascript
function makeDate(timestamp: number): Date;
function makeDate(m: number, d: number, y: number): Date;
```
