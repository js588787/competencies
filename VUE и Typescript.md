# Знает жизненный цикл Vue-компонентов

```onBeforeMount, onMounted, onBeforeUpdate, onUpdated, onBeforeUnmount, onUnmounted, onErrorCaptured, onRenderTracked, onRenderTriggered, onActivated, onDeactivated```

```onErrorCaptured``` - будет вызван при обнаружении ошибки, распространяющейся от дочернего компонента
```onRenderTracked``` - позволяет отследить момент когда именно изменились данные, вызвавшие перерисовку
```onRenderTriggered``` - вызываться, когда реактивная зависимость запускает повторный запуск эффекта рендеринга компонента
```onActivated``` - будет вызван после вставки экземпляра компонента в DOM как часть дерева, кэшированного <KeepAlive>
```onServerPrefetch``` - регистрирует асинхронную функцию, которая должна быть разрешена до того, как экземпляр компонента будет отрисован на сервере

# Знает, что такое vue-router

Vue Router — это официальный маршрутизатор для Vue.js, который позволяет создавать одностраничные приложения (SPA) с навигацией между различными маршрутами. Vue Router предоставляет мощные возможности для управления URL-адресами и представлениями в приложении, делая навигацию между страницами или компонентами более плавной и эффективной.

Основные возможности Vue Router:
- Маршрутизация: Определение маршрутов и связывания их с компонентами или страницами.
- Глубокое связывание: Связывание маршрутов с компонентами на основе пути URL, что позволяет создавать сложные SPA.
- Параметры маршрута: Поддержка параметров в URL для динамической навигации.
- Переадресация и отказ: Управление перенаправлением пользователей между маршрутами.
- Защита маршрутов: Автоматическое разрешение или запрет доступа к маршрутам на основе условий.
- Lazy Loading: Загрузка компонентов маршрутов по мере необходимости для улучшения производительности.
- История браузера: Управление историей браузера для навигации назад и вперед.

# Для чего нужен key в компонентах
Атрибут key в Vue.js играет критически важную роль в оптимизации процесса рендеринга, особенно при работе с директивой v-for для перебора массивов. Каждый элемент в списке должен иметь уникальный key, который помогает Vue идентифицировать каждый элемент списка и эффективно обновлять DOM при изменении данных.

Зачем нужен key?
Оптимизация рендеринга: Когда данные списка изменяются (например, элементы добавляются, удаляются или перемещаются), Vue использует key для определения, какие элементы нужно перерисовать, а какие оставить без изменений. Это значительно улучшает производительность, особенно при работе с большими списками.
Предотвращение ошибок: Без уникальных ключей Vue может смешивать свойства элементов при изменении массива, что приводит к неправильному отображению данных.

# Какие есть препроцессоры и как их использовать (Sass/SCSS, PostCSS)

Препроцессоры CSS, такие как Sass/SCSS и PostCSS, позволяют расширять стандартный синтаксис CSS, добавляя новые возможности и функции, что делает процесс написания стилей более мощным и удобным. Код, написанный с использованием препроцессоров компилируется в css, это можно доверить сборщикам.

Sass/SCSS
-
Sass (Syntactically Awesome Stylesheets) — это препроцессор CSS, который добавляет множество новых возможностей, таких как переменные, миксины, наследование, импорт и многое другое. Sass поддерживает два основных синтаксиса: оригинальный Sass (с использованием Ruby) и SCSS (Syntactically Awesome Stylesheets), который является более современным и ближе к синтаксису CSS.

Основные концепции SCSS:
Переменные — позволяют определить значения, которые можно повторно использовать в стилевой таблице. Это особенно полезно для цветов, шрифтов и других часто используемых значений.
```css
$primary-color: #3498db;

body {
  background-color: $primary-color;
}
```

Миксины — это группы деклараций, которые можно повторно использовать в различных селекторах. Миксины могут принимать аргументы, что делает их очень гибкими.
```css
@mixin transform($property) {
  -webkit-transform: $property;
  -ms-transform: $property;
  transform: $property;
}

.box { 
  @include transform(rotate(30deg)); 
}
```

Наследование - позволяет одному селектору наследовать свойства другого селектора. Это упрощает повторное использование стилей.
```css
.base-text {
  color: $primary-color;
}

.text-large {
  @extend .base-text;
  font-size: 20px;
}
```

Импорт - позволяет включать стили из других файлов SCSS. Это удобно для организации больших проектов.
```css
@import 'variables';
@import 'mixins';
Инкременты и операции
SCSS поддерживает математические операции и инкременты, что позволяет создавать динамические значения.

$font-size-base: 16px;

.container {
  font-size: $font-size-base * 1.5;
}
```

Кондициональные операторы - SCSS поддерживает условные операторы, такие как if, else if и else, что позволяет создавать динамические стили.
```css
$theme: dark;

body {
  background-color: $theme == dark ? black : white;
}
```

PostCSS
-
Это инструмент для трансформации CSS с помощью JavaScript-плагинов, который позволяет модифицировать CSS перед его применением в браузере. Он предлагает гибкую систему для расширения возможностей CSS, что делает его мощным инструментом для современной веб-разработки. Вот ключевые аспекты, которые стоит знать о PostCSS:
- Трансформация CSS: PostCSS преобразует CSS в абстрактное синтаксическое дерево (AST), что позволяет анализировать и модифицировать его с помощью JavaScript-плагинов.
- Экосистема плагинов: PostCSS поддерживает широкий спектр плагинов, включая Autoprefixer для добавления префиксов, Stylelint для статической проверки стилей, CSSNano для минификации CSS, и многие другие.
- Независимость от спецификаций CSS: В отличие от препроцессоров, таких как Sass или Less, PostCSS не привязан к конкретным спецификациям CSS. Это означает, что он может работать с любым CSS, независимо от его структуры или синтаксиса.
- Интеграция с другими технологиями: PostCSS может использоваться вместе с препроцессорами, такими как Sass, Less, Stylus, или как альтернатива им, поскольку он обладает всеми необходимыми функциями для самостоятельного использования.
- PostCSS требует настройки в конфиге postcss.config.js.
