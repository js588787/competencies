# Знает жизненный цикл Vue-компонентов

```onBeforeMount, onMounted, onBeforeUpdate, onUpdated, onBeforeUnmount, onUnmounted, onErrorCaptured, onRenderTracked, onRenderTriggered, onActivated, onDeactivated```

```onErrorCaptured``` - будет вызван при обнаружении ошибки, распространяющейся от дочернего компонента
```onRenderTracked``` - позволяет отследить момент когда именно изменились данные, вызвавшие перерисовку
```onRenderTriggered``` - вызываться, когда реактивная зависимость запускает повторный запуск эффекта рендеринга компонента
```onActivated``` - будет вызван после вставки экземпляра компонента в DOM как часть дерева, кэшированного <KeepAlive>
```onServerPrefetch``` - регистрирует асинхронную функцию, которая должна быть разрешена до того, как экземпляр компонента будет отрисован на сервере

# Знает, что такое vue-router

Vue Router — это официальный маршрутизатор для Vue.js, который позволяет создавать одностраничные приложения (SPA) с навигацией между различными маршрутами. Vue Router предоставляет мощные возможности для управления URL-адресами и представлениями в приложении, делая навигацию между страницами или компонентами более плавной и эффективной.

Основные возможности Vue Router:
- Маршрутизация: Определение маршрутов и связывания их с компонентами или страницами.
- Глубокое связывание: Связывание маршрутов с компонентами на основе пути URL, что позволяет создавать сложные SPA.
- Параметры маршрута: Поддержка параметров в URL для динамической навигации.
- Переадресация и отказ: Управление перенаправлением пользователей между маршрутами.
- Защита маршрутов: Автоматическое разрешение или запрет доступа к маршрутам на основе условий.
- Lazy Loading: Загрузка компонентов маршрутов по мере необходимости для улучшения производительности.
- История браузера: Управление историей браузера для навигации назад и вперед.

# Для чего нужен key в компонентах
Атрибут key в Vue.js играет критически важную роль в оптимизации процесса рендеринга, особенно при работе с директивой v-for для перебора массивов. Каждый элемент в списке должен иметь уникальный key, который помогает Vue идентифицировать каждый элемент списка и эффективно обновлять DOM при изменении данных.

Зачем нужен key?
Оптимизация рендеринга: Когда данные списка изменяются (например, элементы добавляются, удаляются или перемещаются), Vue использует key для определения, какие элементы нужно перерисовать, а какие оставить без изменений. Это значительно улучшает производительность, особенно при работе с большими списками.
Предотвращение ошибок: Без уникальных ключей Vue может смешивать свойства элементов при изменении массива, что приводит к неправильному отображению данных.

# Какие есть препроцессоры и как их использовать (Sass/SCSS, PostCSS)

Препроцессоры CSS, такие как Sass/SCSS и PostCSS, позволяют расширять стандартный синтаксис CSS, добавляя новые возможности и функции, что делает процесс написания стилей более мощным и удобным. Код, написанный с использованием препроцессоров компилируется в css, это можно доверить сборщикам.

Sass/SCSS
-
Sass (Syntactically Awesome Stylesheets) — это препроцессор CSS, который добавляет множество новых возможностей, таких как переменные, миксины, наследование, импорт и многое другое. Sass поддерживает два основных синтаксиса: оригинальный Sass (с использованием Ruby) и SCSS (Syntactically Awesome Stylesheets), который является более современным и ближе к синтаксису CSS.

Основные концепции SCSS:
Переменные — позволяют определить значения, которые можно повторно использовать в стилевой таблице. Это особенно полезно для цветов, шрифтов и других часто используемых значений.
```css
$primary-color: #3498db;

body {
  background-color: $primary-color;
}
```

Миксины — это группы деклараций, которые можно повторно использовать в различных селекторах. Миксины могут принимать аргументы, что делает их очень гибкими.
```css
@mixin transform($property) {
  -webkit-transform: $property;
  -ms-transform: $property;
  transform: $property;
}

.box { 
  @include transform(rotate(30deg)); 
}
```

Наследование - позволяет одному селектору наследовать свойства другого селектора. Это упрощает повторное использование стилей.
```css
.base-text {
  color: $primary-color;
}

.text-large {
  @extend .base-text;
  font-size: 20px;
}
```

Импорт - позволяет включать стили из других файлов SCSS. Это удобно для организации больших проектов.
```css
@import 'variables';
@import 'mixins';
Инкременты и операции
SCSS поддерживает математические операции и инкременты, что позволяет создавать динамические значения.

$font-size-base: 16px;

.container {
  font-size: $font-size-base * 1.5;
}
```

Кондициональные операторы - SCSS поддерживает условные операторы, такие как if, else if и else, что позволяет создавать динамические стили.
```css
$theme: dark;

body {
  background-color: $theme == dark ? black : white;
}
```

PostCSS
-
Это инструмент для трансформации CSS с помощью JavaScript-плагинов, который позволяет модифицировать CSS перед его применением в браузере. Он предлагает гибкую систему для расширения возможностей CSS, что делает его мощным инструментом для современной веб-разработки. Вот ключевые аспекты, которые стоит знать о PostCSS:
- Трансформация CSS: PostCSS преобразует CSS в абстрактное синтаксическое дерево (AST), что позволяет анализировать и модифицировать его с помощью JavaScript-плагинов.
- Экосистема плагинов: PostCSS поддерживает широкий спектр плагинов, включая Autoprefixer для добавления префиксов, Stylelint для статической проверки стилей, CSSNano для минификации CSS, и многие другие.
- Независимость от спецификаций CSS: В отличие от препроцессоров, таких как Sass или Less, PostCSS не привязан к конкретным спецификациям CSS. Это означает, что он может работать с любым CSS, независимо от его структуры или синтаксиса.
- Интеграция с другими технологиями: PostCSS может использоваться вместе с препроцессорами, такими как Sass, Less, Stylus, или как альтернатива им, поскольку он обладает всеми необходимыми функциями для самостоятельного использования.
- PostCSS требует настройки в конфиге postcss.config.js.

# Знает, для чего нужна Pinia, как ее применять на проекте

Pinia — это библиотека управления состоянием для Vue.js, созданная с целью предложить более простой и мощный интерфейс для работы с состоянием приложения по сравнению с Vuex. Она была разработана с учетом обратной связи от сообщества Vue и стремится обеспечить лучшую производительность, более простой API и лучшую интеграцию с Vue 3.

Основные характеристики Pinia:
- Простота использования: Pinia предлагает простой и интуитивно понятный API для управления состоянием, что делает его доступным даже для начинающих разработчиков.
- Производительность: Pinia оптимизирован для работы с Vue 3 Composition API, что позволяет достигать лучшей производительности по сравнению с Vuex.
- Модульность: Pinia позволяет создавать отдельные хранилища состояния для различных частей приложения, что упрощает тестирование и поддержку кода.
- Интеграция с Vue Devtools: Pinia хорошо интегрируется с Vue Devtools, предоставляя удобные инструменты для отладки состояния приложения.
- Поддержка TypeScript: Pinia поддерживает TypeScript, что делает его идеальным выбором для проектов на TypeScript.

Основные концепции Pinia:
- Хранилища: В Pinia состояние приложения организуется в хранилища, каждое из которых имеет уникальный идентификатор. Хранилища могут содержать состояние, действия и getters.
- Actions: Actions позволяют изменять состояние хранилища. Они могут быть асинхронными и могут вызывать другие actions.
- Getters: Getters предоставляют способ вычислять и возвращать значения на основе состояния хранилища.
- Pinia Plugin System: Pinia поддерживает плагины, что позволяет расширять его функциональность.

# Знает для чего нужны: axios, window.fetch

Axios и window.fetch являются популярными методами для выполнения HTTP-запросов в JavaScript, но они имеют ряд отличий в своей реализации и возможностях. Эти различия влияют на выбор между ними в зависимости от конкретных требований проекта.

Axios
-
Это библиотека, созданная для выполнения HTTP-запросов. Она предоставляет более высокоуровневый API по сравнению с fetch и включает в себя множество дополнительных функций, которые делают ее удобной для использования в различных сценариях.

Основные особенности Axios:
- Более дружелюбный API: Axios предоставляет более простой и понятный интерфейс для выполнения запросов и обработки ответов.
- Обработка ошибок: Axios автоматически преобразует ошибки HTTP в исключения, что упрощает обработку ошибок.
- Преобразование данных: Axios позволяет легко преобразовывать ответы в JSON и отправлять запросы с JSON-данными без необходимости явного указания типа данных.
- Отмена запросов: Axios поддерживает отмену запросов, что может быть полезно для предотвращения ненужных сетевых запросов.
- Прогресс-бар: Axios поддерживает прогресс-бары для загрузки файлов, что может быть полезно при загрузке больших файлов.

Window.fetch
-
Это нативный метод для выполнения HTTP-запросов, доступный в современных браузерах. Он является частью Fetch API и предназначен для замены XMLHttpRequest.

Основные особенности fetch:
- Promise-based: fetch возвращает Promise, что делает его асинхронным и позволяет использовать современные возможности ES6 для работы с асинхронностью.
- Стандартный API: fetch является частью стандарта и доступен в большинстве современных браузеров без необходимости использования сторонних библиотек.
- Отсутствие обработки ошибок: В отличие от Axios, fetch не преобразует статусы HTTP ошибок (например, 404 или 500) в исключения. Вместо этого, эти статусы считаются успешными, и для их обработки необходимо проверять свойство ok объекта Response.
- Меньше функциональности: fetch предоставляет базовые возможности для выполнения HTTP-запросов и получения ответов, но не включает некоторые продвинутые функции, доступные в Axios.

# Знает что нового принес composition API

Composition API, введенная в Vue 3, представляет собой радикальное улучшение над предыдущим подходом к организации кода в Vue.js, известным как Options API. Composition API предлагает более гибкий и мощный способ создания компонентов, позволяя разработчикам лучше структурировать и переиспользовать логику компонентов. Вот что принесло Composition API в Vue.js:
- Переиспользование логики: Composition API позволяет создавать "composables" — функции, которые группируют и переиспользуют логику компонентов. Это решает проблемы, связанные с переиспользованием логики в Options API, например, с миксинами, и делает код более чистым и модульным.
- Более гибкая организация кода: API основано на функциональном подходе, что позволяет более гибко организовывать код внутри компонентов. Разработчики могут выбирать, какие части логики должны быть доступны в шаблоне компонента, а какие остаются скрытыми внутри setup() функции.
- Улучшенная поддержка TypeScript: Composition API тесно интегрирована с TypeScript, что делает Vue.js более дружелюбным к TypeScript разработчикам. Функции реактивности, такие как ref() и reactive(), автоматически генерируют типы, что уменьшает количество ручной работы и увеличивает безопасность типов.
- Меньший размер пакета и меньше накладных расходов: Использование Composition API может привести к меньшему размеру конечного пакета и меньше накладных расходов по сравнению с Options API, благодаря более эффективному использованию возможностей Vue 3.

Отношение к Options API
-
Options API остается важной частью Vue и не планируется устаревание. Composition API предназначена для более крупномасштабных проектов, где её преимущества становятся очевидными, в то время как Options API продолжает оставаться надежным выбором для многих низко- и средней сложности сценариев.

Использование обоих API в одном компоненте
-
Разработчики могут использовать и Composition API, и Options API в одном компоненте, что позволяет постепенно переходить на новую систему API или интегрировать новые функции с уже существующим кодом на Options API.

Composables в контексте Vue.js и Composition API — это функции, которые помогают организовать и переиспользовать логику компонентов. Они представляют собой способ группировки и повторного использования функциональности между компонентами, что делает код более чистым, легче для чтения и поддержки. Composables используются для решения общих задач, таких как управление состоянием, выполнение асинхронных запросов, взаимодействие с внешними сервисами и многое другое.

Основные характеристики composables:
- Переиспользуемость: Composables могут быть легко импортированы и использованы в любом компоненте, что позволяет избежать дублирования кода.
- Чистота и модульность: Поскольку composables фокусируются на выполнении одной конкретной задачи, они помогают организовать код более четко и модульно.
- Реактивность: Composables могут использовать реактивные функции Vue, такие как reactive и ref, чтобы обеспечить реактивность данных внутри компонентов.

Пример создания и использования composable:
Допустим, у нас есть задача выполнения асинхронного запроса к API. Мы можем создать composable для этой задачи:
```javascript
// useApiRequest.js
import { ref } from 'vue';

export function useApiRequest(url) {
  const data = ref(null);
  const error = ref(null);

  async function fetchData() {
    try {
      const response = await fetch(url);
      data.value = await response.json();
    } catch (err) {
      error.value = err;
    }
  }

  return { data, error, fetchData };
}
```

Преимущества использования composables:
- Уменьшение дублирования кода: Composables позволяют централизованно решать одни и те же задачи, что снижает дублирование кода.
- Улучшение читаемости: Чистые и модульные composables делают код более понятным и легким для чтения.
- Лучшая поддержка TypeScript: Composables могут быть легко типизированы с использованием TypeScript, что улучшает безопасность типов и автодополнение в редакторах кода.

# Зачем нужен Slot

Тут все понятно. Добавлю про scoped slots

В обычном слоте контент определяется в родительском компоненте и вставляется в дочерний. Слот с ограниченной областью видимости работает аналогично, но также позволяет дочернему компоненту передавать данные обратно в родительский через слот. Это достигается путем добавления атрибута v-slot к тегу <template> в родительском компоненте, который принимает значения, переданные из дочернего компонента.

```html
<!-- Дочерний компонент -->
<div class="child-component">
  <slot name="header" :user="user"></slot>
</div>

<!-- Родительский компонент -->
<ChildComponent>
  <template v-slot:header="slotProps">
    <h1>{{ slotProps.user.name }}</h1>
    <p>Age: {{ slotProps.user.age }}</p>
  </template>
</ChildComponent>
```
