# Знает жизненный цикл Vue-компонентов

```onBeforeMount, onMounted, onBeforeUpdate, onUpdated, onBeforeUnmount, onUnmounted, onErrorCaptured, onRenderTracked, onRenderTriggered, onActivated, onDeactivated```

```onErrorCaptured``` - будет вызван при обнаружении ошибки, распространяющейся от дочернего компонента
```onRenderTracked``` - позволяет отследить момент когда именно изменились данные, вызвавшие перерисовку
```onRenderTriggered``` - вызываться, когда реактивная зависимость запускает повторный запуск эффекта рендеринга компонента
```onActivated``` - будет вызван после вставки экземпляра компонента в DOM как часть дерева, кэшированного <KeepAlive>
```onServerPrefetch``` - регистрирует асинхронную функцию, которая должна быть разрешена до того, как экземпляр компонента будет отрисован на сервере

# Знает, что такое vue-router

Vue Router — это официальный маршрутизатор для Vue.js, который позволяет создавать одностраничные приложения (SPA) с навигацией между различными маршрутами. Vue Router предоставляет мощные возможности для управления URL-адресами и представлениями в приложении, делая навигацию между страницами или компонентами более плавной и эффективной.

Основные возможности Vue Router:
- Маршрутизация: Определение маршрутов и связывания их с компонентами или страницами.
- Глубокое связывание: Связывание маршрутов с компонентами на основе пути URL, что позволяет создавать сложные SPA.
- Параметры маршрута: Поддержка параметров в URL для динамической навигации.
- Переадресация и отказ: Управление перенаправлением пользователей между маршрутами.
- Защита маршрутов: Автоматическое разрешение или запрет доступа к маршрутам на основе условий.
- Lazy Loading: Загрузка компонентов маршрутов по мере необходимости для улучшения производительности.
- История браузера: Управление историей браузера для навигации назад и вперед.

# Для чего нужен key в компонентах
Атрибут key в Vue.js играет критически важную роль в оптимизации процесса рендеринга, особенно при работе с директивой v-for для перебора массивов. Каждый элемент в списке должен иметь уникальный key, который помогает Vue идентифицировать каждый элемент списка и эффективно обновлять DOM при изменении данных.

Зачем нужен key?
Оптимизация рендеринга: Когда данные списка изменяются (например, элементы добавляются, удаляются или перемещаются), Vue использует key для определения, какие элементы нужно перерисовать, а какие оставить без изменений. Это значительно улучшает производительность, особенно при работе с большими списками.
Предотвращение ошибок: Без уникальных ключей Vue может смешивать свойства элементов при изменении массива, что приводит к неправильному отображению данных.

# Какие есть препроцессоры и как их использовать (Sass/SCSS, PostCSS)

Препроцессоры CSS, такие как Sass/SCSS и PostCSS, позволяют расширять стандартный синтаксис CSS, добавляя новые возможности и функции, что делает процесс написания стилей более мощным и удобным. Код, написанный с использованием препроцессоров компилируется в css, это можно доверить сборщикам.

Sass/SCSS
-
Sass (Syntactically Awesome Stylesheets) — это препроцессор CSS, который добавляет множество новых возможностей, таких как переменные, миксины, наследование, импорт и многое другое. Sass поддерживает два основных синтаксиса: оригинальный Sass (с использованием Ruby) и SCSS (Syntactically Awesome Stylesheets), который является более современным и ближе к синтаксису CSS.

Основные концепции SCSS:
Переменные — позволяют определить значения, которые можно повторно использовать в стилевой таблице. Это особенно полезно для цветов, шрифтов и других часто используемых значений.
```css
$primary-color: #3498db;

body {
  background-color: $primary-color;
}
```

Миксины — это группы деклараций, которые можно повторно использовать в различных селекторах. Миксины могут принимать аргументы, что делает их очень гибкими.
```css
@mixin transform($property) {
  -webkit-transform: $property;
  -ms-transform: $property;
  transform: $property;
}

.box { 
  @include transform(rotate(30deg)); 
}
```

Наследование - позволяет одному селектору наследовать свойства другого селектора. Это упрощает повторное использование стилей.
```css
.base-text {
  color: $primary-color;
}

.text-large {
  @extend .base-text;
  font-size: 20px;
}
```

Импорт - позволяет включать стили из других файлов SCSS. Это удобно для организации больших проектов.
```css
@import 'variables';
@import 'mixins';
Инкременты и операции
SCSS поддерживает математические операции и инкременты, что позволяет создавать динамические значения.

$font-size-base: 16px;

.container {
  font-size: $font-size-base * 1.5;
}
```

Кондициональные операторы - SCSS поддерживает условные операторы, такие как if, else if и else, что позволяет создавать динамические стили.
```css
$theme: dark;

body {
  background-color: $theme == dark ? black : white;
}
```

PostCSS
-
Это инструмент для трансформации CSS с помощью JavaScript-плагинов, который позволяет модифицировать CSS перед его применением в браузере. Он предлагает гибкую систему для расширения возможностей CSS, что делает его мощным инструментом для современной веб-разработки. Вот ключевые аспекты, которые стоит знать о PostCSS:
- Трансформация CSS: PostCSS преобразует CSS в абстрактное синтаксическое дерево (AST), что позволяет анализировать и модифицировать его с помощью JavaScript-плагинов.
- Экосистема плагинов: PostCSS поддерживает широкий спектр плагинов, включая Autoprefixer для добавления префиксов, Stylelint для статической проверки стилей, CSSNano для минификации CSS, и многие другие.
- Независимость от спецификаций CSS: В отличие от препроцессоров, таких как Sass или Less, PostCSS не привязан к конкретным спецификациям CSS. Это означает, что он может работать с любым CSS, независимо от его структуры или синтаксиса.
- Интеграция с другими технологиями: PostCSS может использоваться вместе с препроцессорами, такими как Sass, Less, Stylus, или как альтернатива им, поскольку он обладает всеми необходимыми функциями для самостоятельного использования.
- PostCSS требует настройки в конфиге postcss.config.js.

# Знает, для чего нужна Pinia, как ее применять на проекте

Pinia — это библиотека управления состоянием для Vue.js, созданная с целью предложить более простой и мощный интерфейс для работы с состоянием приложения по сравнению с Vuex. Она была разработана с учетом обратной связи от сообщества Vue и стремится обеспечить лучшую производительность, более простой API и лучшую интеграцию с Vue 3.

Основные характеристики Pinia:
- Простота использования: Pinia предлагает простой и интуитивно понятный API для управления состоянием, что делает его доступным даже для начинающих разработчиков.
- Производительность: Pinia оптимизирован для работы с Vue 3 Composition API, что позволяет достигать лучшей производительности по сравнению с Vuex.
- Модульность: Pinia позволяет создавать отдельные хранилища состояния для различных частей приложения, что упрощает тестирование и поддержку кода.
- Интеграция с Vue Devtools: Pinia хорошо интегрируется с Vue Devtools, предоставляя удобные инструменты для отладки состояния приложения.
- Поддержка TypeScript: Pinia поддерживает TypeScript, что делает его идеальным выбором для проектов на TypeScript.

Основные концепции Pinia:
- Хранилища: В Pinia состояние приложения организуется в хранилища, каждое из которых имеет уникальный идентификатор. Хранилища могут содержать состояние, действия и getters.
- Actions: Actions позволяют изменять состояние хранилища. Они могут быть асинхронными и могут вызывать другие actions.
- Getters: Getters предоставляют способ вычислять и возвращать значения на основе состояния хранилища.
- Pinia Plugin System: Pinia поддерживает плагины, что позволяет расширять его функциональность.

# Знает для чего нужны: axios, window.fetch

Axios и window.fetch являются популярными методами для выполнения HTTP-запросов в JavaScript, но они имеют ряд отличий в своей реализации и возможностях. Эти различия влияют на выбор между ними в зависимости от конкретных требований проекта.

Axios
-
Это библиотека, созданная для выполнения HTTP-запросов. Она предоставляет более высокоуровневый API по сравнению с fetch и включает в себя множество дополнительных функций, которые делают ее удобной для использования в различных сценариях.

Основные особенности Axios:
- Более дружелюбный API: Axios предоставляет более простой и понятный интерфейс для выполнения запросов и обработки ответов.
- Обработка ошибок: Axios автоматически преобразует ошибки HTTP в исключения, что упрощает обработку ошибок.
- Преобразование данных: Axios позволяет легко преобразовывать ответы в JSON и отправлять запросы с JSON-данными без необходимости явного указания типа данных.
- Отмена запросов: Axios поддерживает отмену запросов, что может быть полезно для предотвращения ненужных сетевых запросов.
- Прогресс-бар: Axios поддерживает прогресс-бары для загрузки файлов, что может быть полезно при загрузке больших файлов.

Window.fetch
-
Это нативный метод для выполнения HTTP-запросов, доступный в современных браузерах. Он является частью Fetch API и предназначен для замены XMLHttpRequest.

Основные особенности fetch:
- Promise-based: fetch возвращает Promise, что делает его асинхронным и позволяет использовать современные возможности ES6 для работы с асинхронностью.
- Стандартный API: fetch является частью стандарта и доступен в большинстве современных браузеров без необходимости использования сторонних библиотек.
- Отсутствие обработки ошибок: В отличие от Axios, fetch не преобразует статусы HTTP ошибок (например, 404 или 500) в исключения. Вместо этого, эти статусы считаются успешными, и для их обработки необходимо проверять свойство ok объекта Response.
- Меньше функциональности: fetch предоставляет базовые возможности для выполнения HTTP-запросов и получения ответов, но не включает некоторые продвинутые функции, доступные в Axios.

# Знает что нового принес composition API

Composition API, введенная в Vue 3, представляет собой радикальное улучшение над предыдущим подходом к организации кода в Vue.js, известным как Options API. Composition API предлагает более гибкий и мощный способ создания компонентов, позволяя разработчикам лучше структурировать и переиспользовать логику компонентов. Вот что принесло Composition API в Vue.js:
- Переиспользование логики: Composition API позволяет создавать "composables" — функции, которые группируют и переиспользуют логику компонентов. Это решает проблемы, связанные с переиспользованием логики в Options API, например, с миксинами, и делает код более чистым и модульным.
- Более гибкая организация кода: API основано на функциональном подходе, что позволяет более гибко организовывать код внутри компонентов. Разработчики могут выбирать, какие части логики должны быть доступны в шаблоне компонента, а какие остаются скрытыми внутри setup() функции.
- Улучшенная поддержка TypeScript: Composition API тесно интегрирована с TypeScript, что делает Vue.js более дружелюбным к TypeScript разработчикам. Функции реактивности, такие как ref() и reactive(), автоматически генерируют типы, что уменьшает количество ручной работы и увеличивает безопасность типов.
- Меньший размер пакета и меньше накладных расходов: Использование Composition API может привести к меньшему размеру конечного пакета и меньше накладных расходов по сравнению с Options API, благодаря более эффективному использованию возможностей Vue 3.

Отношение к Options API
-
Options API остается важной частью Vue и не планируется устаревание. Composition API предназначена для более крупномасштабных проектов, где её преимущества становятся очевидными, в то время как Options API продолжает оставаться надежным выбором для многих низко- и средней сложности сценариев.

Использование обоих API в одном компоненте
-
Разработчики могут использовать и Composition API, и Options API в одном компоненте, что позволяет постепенно переходить на новую систему API или интегрировать новые функции с уже существующим кодом на Options API.

Composables в контексте Vue.js и Composition API — это функции, которые помогают организовать и переиспользовать логику компонентов. Они представляют собой способ группировки и повторного использования функциональности между компонентами, что делает код более чистым, легче для чтения и поддержки. Composables используются для решения общих задач, таких как управление состоянием, выполнение асинхронных запросов, взаимодействие с внешними сервисами и многое другое.

Основные характеристики composables:
- Переиспользуемость: Composables могут быть легко импортированы и использованы в любом компоненте, что позволяет избежать дублирования кода.
- Чистота и модульность: Поскольку composables фокусируются на выполнении одной конкретной задачи, они помогают организовать код более четко и модульно.
- Реактивность: Composables могут использовать реактивные функции Vue, такие как reactive и ref, чтобы обеспечить реактивность данных внутри компонентов.

Пример создания и использования composable:
Допустим, у нас есть задача выполнения асинхронного запроса к API. Мы можем создать composable для этой задачи:
```javascript
// useApiRequest.js
import { ref } from 'vue';

export function useApiRequest(url) {
  const data = ref(null);
  const error = ref(null);

  async function fetchData() {
    try {
      const response = await fetch(url);
      data.value = await response.json();
    } catch (err) {
      error.value = err;
    }
  }

  return { data, error, fetchData };
}
```

Преимущества использования composables:
- Уменьшение дублирования кода: Composables позволяют централизованно решать одни и те же задачи, что снижает дублирование кода.
- Улучшение читаемости: Чистые и модульные composables делают код более понятным и легким для чтения.
- Лучшая поддержка TypeScript: Composables могут быть легко типизированы с использованием TypeScript, что улучшает безопасность типов и автодополнение в редакторах кода.

# Зачем нужен Slot

Тут все понятно. Добавлю про scoped slots

В обычном слоте контент определяется в родительском компоненте и вставляется в дочерний. Слот с ограниченной областью видимости работает аналогично, но также позволяет дочернему компоненту передавать данные обратно в родительский через слот. Это достигается путем добавления атрибута v-slot к тегу <template> в родительском компоненте, который принимает значения, переданные из дочернего компонента.

```html
<!-- Дочерний компонент -->
<div class="child-component">
  <slot name="header" :user="user"></slot>
</div>

<!-- Родительский компонент -->
<ChildComponent>
  <template v-slot:header="slotProps">
    <h1>{{ slotProps.user.name }}</h1>
    <p>Age: {{ slotProps.user.age }}</p>
  </template>
</ChildComponent>
```
Передача данных из scoped slot в родителя происходит через v-bind. Получение в родительском компоненте через v-slot, в v-slot нужно передать переменную в которую будут записываться данные и прописать имя слота.
Доступ к списку слотов можно получить, обратившись к свойству slots или scopedSlots.

# Отслеживание изменение объектов ( watch и его аргументы)

Watch в Vue.js - это механизм, который позволяет отслеживать изменения в данных и выполнять реактивные операции в ответ на них. watch(expression, callback, [options]).

Watch может отслеживать любые реактивные данные, включая методы и свойства.
Он работает асинхронно, что позволяет выполнять длительные операции без блокировки UI.
Watch может принимать как строки, так и функции в качестве выражения.

Типы источников watch​
-
Первым аргументом watch могут быть различные типы реактивных "источников": это может быть ref (включая вычисляемые refs), реактивный объект, геттер-функция или массив из нескольких источников:

```javascript
const x = ref(0)
const y = ref(0)

// одиночный ref
watch(x, (newX) => {
  console.log(`x is ${newX}`)
})

// геттер
watch(
  () => x.value + y.value,
  (sum) => {
    console.log(`сумма x + y равна: ${sum}`)
  }
)

// массив из нескольких источников
watch([x, () => y.value], ([newX, newY]) => {
  console.log(`x равен ${newX} и y равен ${newY}`)
})
```

Аргументы функции обратного вызова
-
Функция обратного вызова в watch, которую вы определяете для отслеживания изменения свойства, может принимать до трех аргументов:
- newValue: Новое значение свойства.
- oldValue: Старое значение свойства.
- instance: Экземпляр компонента, в котором происходит отслеживание. Этот аргумент доступен начиная с Vue 3 и позволяет вам получить доступ к другим свойствам и методам компонента внутри функции обратного вызова.

Дополнительные опции для watch
-
Vue также предоставляет дополнительные опции для более тонкой настройки отслеживания изменений:
- deep: Если установлено значение true, будет отслеживаться глубокое изменение объектов и массивов. Это полезно, когда вам нужно реагировать на изменения вложенных свойств.
- immediate: Если установлено значение true, функция обратного вызова будет выполнена сразу после создания наблюдателя, а не только при изменении значения.

Обратный вызов наблюдателя будет выполняться всякий раз, когда изменяется отслеживаемый источник. Если вы хотите, чтобы обратный вызов запускался только один раз при изменении источника, используйте параметр once: true.

watchEffect()
-
Позволяет нам немедленно выполнить побочный эффект, автоматически отслеживая реактивные зависимости. 

```javascript
watchEffect(async () => {
  const response = await fetch(
    `https://jsonplaceholder.typicode.com/todos/${todoId.value}`
  )
  data.value = await response.json()
})
```

Здесь обратный вызов будет запущен немедленно, нет необходимости указывать ```immediate: true```. Во время его выполнения он будет автоматически отслеживать todoId.value как зависимость (аналогично вычисляемым свойствам). Всякий раз, когда ```todoId.value``` изменяется, обратный вызов будет запущен снова. С помощью ```watchEffect()``` нам больше не нужно явно передавать todoId в качестве источника.

watch vs. watchEffect​
-

```watch``` и ```watchEffect``` позволяют нам реактивно выполнять побочные эффекты. Их основное различие заключается в том, как они отслеживают свои реактивные зависимости:
- ```watch``` отслеживает только явно указанный источник. Он не будет отслеживать ничего, к чему обращаются внутри обратного вызова. Кроме того, обратный вызов срабатывает только тогда, когда источник действительно изменился.
- ```watch``` отделяет отслеживание зависимости от побочного эффекта, давая нам более точный контроль над тем, когда должен сработать обратный вызов.
- ```watchEffect```, с другой стороны, объединяет отслеживание зависимостей и побочный эффект в одну фазу. Он автоматически отслеживает каждое реактивное свойство, доступ к которому осуществляется во время его синхронного выполнения. Это более удобно и обычно приводит к более лаконичному коду, но делает его реактивные зависимости менее явными.

# Привести примеры типов: примитивы, объектные типы, иные (any, object)

Примитивные типы в TypeScript включают в себя:
- string
- number
- boolean
- null
- undefined
- symbol
- bigint

Объектные типы
Объектные типы включают в себя интерфейсы, классы и литеральные типы объектов.

Интерфейсы
Интерфейсы определяют контракты для объектов.

Классы
Классы используются для создания объектов с определенными свойствами и методами.

Литеральные типы объектов
Литеральные типы позволяют определить конкретную форму объекта.

Специальные типы
- any. Тип any используется, когда вы хотите отключить проверку типов для определенного значения.
- unknown. Представляет собой безопасную альтернативу типу any. Все типы могут быть присвоены переменной типа unknown. Переменная типа unknown может быть присвоена только переменным типа unknown или any. На переменной типа unknown нельзя выполнять никаких операций без предварительной проверки или утверждения типа.
- object. Тип object представляет собой более строгую альтернативу any для случаев, когда вам нужно работать с объектами, но вы не знаете их конкретную форму.

Отличия object и unknown
Присваивание значений
unknown: Любое значение можно присвоить переменной типа unknown.
object: Только объектные значения можно присвоить переменной типа object. Примитивные типы нельзя присвоить напрямую.

Использование свойств и методов
unknown: Нельзя использовать свойства или вызывать методы без предварительной проверки типа.
object: Можно использовать свойства и методы, определенные для всех объектов (например, toString()), но доступ к специфическим свойствам конкретных объектов требует дополнительной проверки.

Наследование
unknown: Не является супертипом ни для каких других типов.
object: Является супертипом для всех пользовательских объектов.

Проверка типа
unknown: Требует строгой проверки типа перед использованием.
object: Может потребовать проверку типа, но это менее строгое требование, чем для unknown.

# Зачем нужен оператор keyof

Оператор keyof позволяет получить тип ключей объекта или интерфейса в виде объединения строковых литералов.
```javascript
interface Person {
  name: string;
  age: number;
  location: string;
}

type PersonKeys = keyof Person; // тип: "name" | "age" | "location"
```

- Работает только на уровне типов, поэтому используйте его в сочетании с typeof, когда нужно получить тип значения.
- Используйте keyof для создания более безопасных и гибких типов, особенно при работе с дженериками.

# Поиск типов (Lookup Types)
Lookup Types (или Indexed Access Types) в TypeScript - это мощное средство для получения типов свойств объекта или элементов массива. Они позволяют динамически обращаться к типам на основе строковых литералов или числовых индексов.
Lookup Type имеет вид Type['key'], где Type - это тип объекта или массива, а 'key' - это строковый литерал или числовой индекс.

```javascript
interface IInterfaceType {
  p1: number;
  p2: string;
}
let union: IInterfaceType['p1' | 'p2']; // union: number | string
```
----------

# Перегрузка функций в TS

Перегрузка функций в TypeScript позволяет определять несколько сигнатур для одной и той же функции, каждая из которых описывает различные варианты использования этой функции.
```javascript
function makeDate(timestamp: number): Date;
function makeDate(m: number, d: number, y: number): Date;
```

# Знает, что такое сборщик Vite и как его конфигурировать

Vite - это инструмент сборки, состоящий из двух основных компонентов:
- Dev-сервер, обеспечивающий расширенный функционал, например, быстрый Hot Module Replacement (HMR).
- Команда сборки, связывающая код с Rollup для создания высокооптимизированных статичных ресурсов для продакшена.

не хочу я про эту тоску писать нахуй!!!

# Настройка Nuxt.config, env переменных, API Proxy для разных сред

# Глобальная и локальная обработка ошибок запросов (fetch) в проекте

Глобальная обработка удобна для централизованного логирования и базовой обработки ошибок.
Локальная обработка дает больше контроля над поведением при возникновении ошибок в конкретных частях приложения.
Комбинированный подход часто является оптимальным решением: глобальная обработка для базового логирования и локальная для специфичной обработки ошибок.

Глобальную обработку ошибок можно реализовать с помощью обертки на fetch. 
Локальная в ```.catch(error => {```

# Для чего нужен и как работает useFetch, useAsyncData, параметры. Как применять вместе с Pinia
useFetch - это композабл функция в Nuxt 3, предназначенная для простого выполнения HTTP-запросов.

Основные особенности:
- Простота использования: принимает URL и автоматически выполняет GET-запрос.
- Реактивность: возвращает реактивный объект с данными, статусом загрузки и ошибками.
- Кэширование: автоматически кэширует результаты запросов.

```javascript
const { data, pending, error, refresh } = await useFetch('https://api.example.com/data');
```

useAsyncData - это более гибкая композабл функция для асинхронной загрузки данных.

Ключевые моменты:
- Гибкость: позволяет использовать любую логику для получения данных, не только HTTP-запросы.
- Интеграция с системой предварительной загрузки данных Nuxt.
- Автоматическое кэширование и обновление данных.
- Поддержка серверного рендеринга (SSR).

```javascript
const { data, pending, error, refresh } = await useAsyncData('key', async () => {
  // Здесь может быть любая асинхронная логика
  return await $fetch('https://api.example.com/data')
})
```

В Nuxt 3 оба метода useFetchи useAsyncData используются для извлечения данных в компоненте, но у них разные варианты использования и поведение:

useFetch
-
Назначение: в основном используется для выполнения HTTP-запросов внутри компонентов, аналогично fetchJavaScript.

Функции :
- SSR: запускается как на сервере, так и на клиенте. На стороне сервера он извлекает данные во время рендеринга, а на стороне клиента он извлекает данные, если они запрашиваются после начальной загрузки страницы.
- Реактивные данные: возвращаемые данные useFetchявляются реактивными, что означает, что любые изменения в данных автоматически обновят компонент.
- Обработка ошибок: вы можете обрабатывать ошибки напрямую, используя коллбек onError.

useAsyncData
-
Назначение: используется для асинхронной выборки и кэширования данных, часто используется на страницах или в компонентах, где данные необходимо предварительно извлечь.
Функции:
- Автоматическое кэширование: кэширует извлеченные данные, поэтому последующие запросы тех же данных не вызывают новую выборку, что полезно для оптимизации производительности.
- Интеграция с извлечением данных Nuxt: useAsyncDataтесно интегрирован с системой асинхронного извлечения данных Nuxt, что делает его идеальным для использования на страницах и в компонентах, где требуется предварительная выборка данных перед рендерингом.
- Состояния ошибок и загрузки: подобно useFetch, он предоставляет реактивные свойства для данных, ошибок и состояний загрузки.
- Рендеринг на стороне сервера: также хорошо работает с SSR, извлекая данные на стороне сервера и передавая их клиенту.
  
Ключевые различия
-
Кэширование: useAsyncData автоматически кэширует данные, а useFetch нет.
Вариант использования: useFetch больше подходит для простых HTTP-запросов внутри компонента, а также useAsyncData лучше подходит для извлечения данных, которые необходимо предварительно визуализировать или кэшировать.
Интеграция с Nuxt: useAsyncData более глубоко интегрирован с механизмами извлечения и кэширования данных Nuxt, что делает его предпочтительным выбором для извлечения данных страниц.

# Разница между Options и Composition API

Options API
-
Options API был первым официальным API для Vue.js и по-прежнему широко используется в современных проектах.

Основные характеристики:
- Базируется на объекте data
- Использует методы жизненного цикла (created, mounted, updated)
- Поддерживает синтаксис JSX
- Имеет ограниченную поддержку асинхронного кода

Composition API
-
Composition API был введен в Vue 3 и предлагает новый способ организации кода.

Основные характеристики:
- Базируется на функциональных компонентах
- Использует setup() функцию для объявления состояния и методов
- Предоставляет реактивные переменные через ref и reactive
- Полностью поддерживает асинхронный код

Ключевые различия
- Структура кода:
    Options API использует объект, где свойства и методы объявляются напрямую.
    Composition API использует функцию setup(), где все логика объявляется внутри нее.

- Гибкость и переиспользование:
    Composition API предоставляет больше гибкости благодаря использованию ref и reactive.
    Легче переиспользовать логику между компонентами.

- Асинхронность:
    Composition API полностью поддерживает асинхронный код из коробки.
    Options API требует дополнительных шагов для работы с асинхронностью.

Управление состоянием:
    Composition API предоставляет более продвинутый механизм управления состоянием через ref и reactive.

# Vue Suspense, как и для чего используется

Vue Suspense - это встроенный компонент, который:
- Обеспечивает централизованное управление асинхронными зависимостями в дереве компонентов.
- Позволяет отображать состояние загрузки в ожидании разрешения нескольких вложенных асинхронных зависимостей.
- Предоставляет два слота: по умолчанию и fallback для отображения состояния загрузки.
- Используется в компонентах с асинхронным сетапом, либо для асинхронных компонентов.

Для работы компонент оборачивается в тег Suspense.
Можно использовать один общий суспенс для вложенных компонентов.

# Может рассказать о регистрации компонентов
Глобальная регистрация позволяет использовать компоненты во всем приложении.
```javascript
app.component('ComponentA', ComponentA)
```

Локальная регистрация ограничивает область видимости компонента конкретным компонентом.
```javascript
export default {
  components: {
    ComponentA
  }
}
```

Ключевые моменты:
- Глобальная регистрация удобна, но может привести к увеличению размера сборки из-за невозможности tree-shaking.
- Локальная регистрация делает зависимости более явными и улучшает поддержку tree-shaking.
- При использовании <script setup> импортированные компоненты автоматически доступны в шаблоне без дополнительной регистрации.
- Рекомендуется использовать имена компонентов в PascalCase для лучшей читаемости и совместимости.

# Понимает как использовать и подключить i18n к проекту
- установить пакет
- создать файл конфигурации
- подключить ```app.use(i18n)```
- использовать в компонентах ```const { t } = useI18n()```
- хранить переводы в отдельных словарях для каждой локали

# Умеет настраивать Tailwind для проекта
- установить пакет и зависимости
- проинициализировать конфиг ```yarn tailwindcss init -p``` это создаст два новых файла: tailwind.config.js и postcss.config.js
- указать в конфиге обрабатываемые файлы, иначе tw не применит стили
```javascript
content: [
    "./index.html",
    "./src/**/*.{vue,js,ts,jsx,tsx}",
  ],
```

- В файле postcss.config.js добавить следующее содержимое
```javascript
module.exports = {
  plugins: ['tailwindcss', 'autoprefixer'],
}
```

Можно настроить тему Tailwind в tailwind.config.js. Например, настроить цветовую палитру, анимации, определить контрольные точки перестроения интерфейса, подключить плагины и определить кастомные стили.

# Подключение плагинов

Плагины - это самодостаточные единицы кода, которые добавляют функциональность на уровне всего приложения. Они могут быть объектом с методом install() или функцией.

Плагины часто используются для:
- Добавления глобальных методов или свойств
- Добавления глобальных ресурсов (директив, переходов и т.д.)
- Добавления опций компонентам через глобальный миксин
- Создания собственных API

Для подключения плагина используется метод ```use()``` после создания приложения с ```createApp()```.

Подключение плагинов в Nuxt.js имеет некоторые отличия от стандартного Vue.js, так как Nuxt использует свои собственные механизмы для управления плагинами.

Самый простой способ подключить плагин - добавить его в секцию modules в файле nuxt.config.js:
```javascript
// nuxt.config.js
export default {
  modules: [
    // другие модули...
    '@nuxtjs/auth',
    ['@nuxtjs/google-analytics', {}]
  ]
}
```

Подключение через директорию plugins
Создайте директорию plugins в корне вашего проекта и поместите в нее файлы плагинов. Затем укажите путь к этим файлам в nuxt.config.js:
```javascript
// nuxt.config.js
export default {
  plugins: [
    '~/plugins/my-plugin.js'
  ]
}
```

# Валидация компонентов во vue (vuelidate)

Vuelidate - это библиотека для валидации форм в Vue.js. Она позволяет легко добавлять валидацию и управлять ей.

Для установки Vuelidate нужно выполнить следующие шаги:
- Установить зависимости: ```npm install @vuelidate/core @vuelidate/validators```
- Импортировать необходимые компоненты:
```javascript
import { useVuelidate } from "@vuelidate/core"
import { required, numeric, email, url, helpers } from "@vuelidate/validators"
```

Настройка валидации:
- Создайте объект данных с v$ для управления валидацией
- Определите правила валидации в rules:
```javascript
    const rules = computed(() => ({
      name: {
        required,
        minLength: minLength(requiredNameLength.value)
      },
    }))

    const v$ = useVuelidate(rules, { name })
```

# Знает для чего нужен Nuxt, как его подключить к проекту
Nuxt.js - это фреймворк, построенный на основе Vue.js, который упрощает разработку серверного рендеринга (SSR), статических сайтов и других типов веб-приложений.

Для чего нужен Nuxt
- Маршрутизация на основе файлов: определение маршрутов на основе структуры каталога ```pages/```. Это помогает избежать необходимости ручной настройки маршрутов.
- Разделение кода: Nuxt автоматически разделяет код на более мелкие фрагменты, что позволяет сократить начальное время загрузки приложения.
- Готовый к использованию серверный рендеринг: Nuxt поставляется со встроенными возможностями SSR.
- Автоматический импорт.
- Утилиты для извлечения данных: Nuxt предоставляет компоненты для извлечения данных, совместимого с SSR.
- Поддержка TypeScript с нулевой конфигурацией.
- Настроенные инструменты сборки: Nuxt использует Vite по умолчанию.

Как подключить Nuxt к проекту
- Установка Node.js версии 18.0.0 или новее.
- Создание нового проекта: открыть терминал и выполнить команду: ```npx nuxi@latest init <project-name>```
- Перейти в директорию проекта: ```cd <project-name>```
- Запустить проект: ```npx nuxi dev```

# Generic-типы, ограничения
Generic-типы - это параметры типа, которые позволяют создавать общие функции и классы, которые могут работать с разными типами данных.

Ограничения generic-типов позволяют задать конкретные требования к типам, используемым с generic-типом.

Ограничения generic-типов определяются с помощью ключевого слова extends.
Например: ```<T extends object>``` означает, что ```T``` может быть любым типом, наследующим от ```object```.

Можно применять ограничения к интерфейсам, классам и функциям.
Ограничения обеспечивают согласованность типов и доступ к определенным свойствам или методам.

Пример ограничения для функции:
```javascript
function merge<T extends object, U extends object>(obj1: T, obj2: U): T & U {
  return { ...obj1, ...obj2 };
}
```
Эта функция теперь работает только с объектами.

Ограничения с интерфейсами:
Можно использовать ограничения для определения структуры типов. Например: ```<T extends { id: number; name: string}>``` гарантирует наличие свойств id и name в типе T.

Ограничение для функции:
```javascript
function identity<T extends unknown>(arg: T): T {
  return arg;
}
```
Эта функция работает только с неизвестными типами.

Ограничение для интерфейса:
```javascript
interface Lengthwise {
  length: number;
}

function loggingIdentity<T extends Lengthwise>(arg: T): T {
  console.log(arg.length);
  return arg;
}
```
Здесь T должен иметь свойство length 2.

Ограничение для класса:
```javascript
abstract class Animal {
  constructor(public name: string) {}
}

class Dog extends Animal {
  bark() {
    console.log(`${this.name} says Woof!`);
  }
}
```
Здесь Dog должен наследоваться от Animal.

# Рекурсивные типы, привести пример
Рекурсивные типы в TypeScript - это типы, которые содержат сами себя. 
Пример рекурсивного типа - дерево:
```javascript
type Tree<T> = {
  value: T;
  left?: Tree<T>;
  right?: Tree<T>;
};
```
Этот тип представляет собой дерево, где каждый узел может иметь левое и правое поддерево того же типа.

Тип списка:
```javascript
type List<T> = T | List<T>;
```
Этот тип представляет собой список, который может содержать элементы типа T или другой список того же типа.

Способы создания адаптивных блоков, плюсы и минусы (flex, grid, bootstrap, tailwind, vw, vh и тд)
Умеет настраивать Nuxt на проекте для SSR
Имеет опыт написания своих модулей/сложных компонентов
Async Components, Teleport Components
Может рассказать об особенности рендеринга компонентов во Vue
Анимация (Transitions, Transition Groups)
